"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pythnetwork";
exports.ids = ["vendor-chunks/@pythnetwork"];
exports.modules = {

/***/ "(ssr)/./node_modules/@pythnetwork/client/lib/PythConnection.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pythnetwork/client/lib/PythConnection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (void 0) && (void 0).__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PythConnection = void 0;\nvar index_1 = __webpack_require__(/*! ./index */ \"(ssr)/./node_modules/@pythnetwork/client/lib/index.js\");\nvar ONES = \"11111111111111111111111111111111\";\n/**\n * Reads Pyth price data from a solana web3 connection. This class uses a callback-driven model,\n * similar to the solana web3 methods for tracking updates to accounts.\n */ var PythConnection = /** @class */ function() {\n    /** Create a PythConnection that reads its data from an underlying solana web3 connection.\n     *  pythProgramKey is the public key of the Pyth program running on the chosen solana cluster.\n     */ function PythConnection(connection, pythProgramKey, commitment) {\n        if (commitment === void 0) {\n            commitment = \"finalized\";\n        }\n        this.productAccountKeyToProduct = {};\n        this.priceAccountKeyToProductAccountKey = {};\n        this.callbacks = [];\n        this.connection = connection;\n        this.pythProgramKey = pythProgramKey;\n        this.commitment = commitment;\n    }\n    PythConnection.prototype.handleProductAccount = function(key, account) {\n        var _a = index_1.parseProductData(account.data), priceAccountKey = _a.priceAccountKey, type = _a.type, product = _a.product;\n        this.productAccountKeyToProduct[key.toString()] = product;\n        if (priceAccountKey.toString() !== ONES) {\n            this.priceAccountKeyToProductAccountKey[priceAccountKey.toString()] = key.toString();\n        }\n    };\n    PythConnection.prototype.handlePriceAccount = function(key, account) {\n        var product = this.productAccountKeyToProduct[this.priceAccountKeyToProductAccountKey[key.toString()]];\n        if (product === undefined) {\n            // This shouldn't happen since we're subscribed to all of the program's accounts,\n            // but let's be good defensive programmers.\n            throw new Error(\"Got a price update for an unknown product. This is a bug in the library, please report it to the developers.\");\n        }\n        var priceData = index_1.parsePriceData(account.data);\n        for(var _i = 0, _a = this.callbacks; _i < _a.length; _i++){\n            var callback = _a[_i];\n            callback(product, priceData);\n        }\n    };\n    PythConnection.prototype.handleAccount = function(key, account, productOnly) {\n        var base = index_1.parseBaseData(account.data);\n        // The pyth program owns accounts that don't contain pyth data, which we can safely ignore.\n        if (base) {\n            switch(index_1.AccountType[base.type]){\n                case \"Mapping\":\n                    break;\n                case \"Product\":\n                    this.handleProductAccount(key, account);\n                    break;\n                case \"Price\":\n                    if (!productOnly) {\n                        this.handlePriceAccount(key, account);\n                    }\n                    break;\n                case \"Test\":\n                    break;\n                default:\n                    throw new Error(\"Unknown account type: \" + base.type + \". Try upgrading pyth-client.\");\n            }\n        }\n    };\n    /** Start receiving price updates. Once this method is called, any registered callbacks will be invoked\n     *  each time a Pyth price account is updated.\n     */ PythConnection.prototype.start = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var accounts, _i, accounts_1, account;\n            var _this = this;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.connection.getProgramAccounts(this.pythProgramKey, this.commitment)\n                        ];\n                    case 1:\n                        accounts = _a.sent();\n                        for(_i = 0, accounts_1 = accounts; _i < accounts_1.length; _i++){\n                            account = accounts_1[_i];\n                            this.handleAccount(account.pubkey, account.account, true);\n                        }\n                        this.connection.onProgramAccountChange(this.pythProgramKey, function(keyedAccountInfo, context) {\n                            _this.handleAccount(keyedAccountInfo.accountId, keyedAccountInfo.accountInfo, false);\n                        }, this.commitment);\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    /** Register callback to receive price updates. */ PythConnection.prototype.onPriceChange = function(callback) {\n        this.callbacks.push(callback);\n    };\n    /** Stop receiving price updates. Note that this also currently deletes all registered callbacks. */ PythConnection.prototype.stop = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                // There's no way to actually turn off the solana web3 subscription x_x, but there should be.\n                // Leave this method in so we don't have to update our API when solana fixes theirs.\n                // In the interim, delete callbacks.\n                this.callbacks = [];\n                return [\n                    2 /*return*/ \n                ];\n            });\n        });\n    };\n    return PythConnection;\n}();\nexports.PythConnection = PythConnection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHB5dGhuZXR3b3JrL2NsaWVudC9saWIvUHl0aENvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNBLElBQUlPLGNBQWMsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxXQUFXLElBQUssU0FBVWxCLE9BQU8sRUFBRW1CLElBQUk7SUFDbkUsSUFBSUMsSUFBSTtRQUFFQyxPQUFPO1FBQUdDLE1BQU07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QyxPQUFPOzRCQUMzRkwsTUFBTVIsYUFBYSxDQUFDWSxpQkFBaUJFLFNBQVMsRUFBRUYsaUJBQWlCRyxXQUFXLEVBQUU7d0JBQ2xGLEdBQUcsSUFBSSxDQUFDckMsVUFBVTt3QkFDbEIsT0FBTzs0QkFBQyxFQUFFLFFBQVE7eUJBQUc7Z0JBQzdCO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsZ0RBQWdELEdBQ2hETixlQUFlVSxTQUFTLENBQUNrQyxhQUFhLEdBQUcsU0FBVWpCLFFBQVE7UUFDdkQsSUFBSSxDQUFDbEIsU0FBUyxDQUFDYixJQUFJLENBQUMrQjtJQUN4QjtJQUNBLGtHQUFrRyxHQUNsRzNCLGVBQWVVLFNBQVMsQ0FBQ21DLElBQUksR0FBRztRQUM1QixPQUFPekYsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxPQUFPbUIsWUFBWSxJQUFJLEVBQUUsU0FBVXVDLEVBQUU7Z0JBQ2pDLDZGQUE2RjtnQkFDN0Ysb0ZBQW9GO2dCQUNwRixvQ0FBb0M7Z0JBQ3BDLElBQUksQ0FBQ0wsU0FBUyxHQUFHLEVBQUU7Z0JBQ25CLE9BQU87b0JBQUMsRUFBRSxRQUFRO2lCQUFHO1lBQ3pCO1FBQ0o7SUFDSjtJQUNBLE9BQU9UO0FBQ1g7QUFDQUQsc0JBQXNCLEdBQUdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHJpZnQtdHJhZGluZy11aS8uL25vZGVfbW9kdWxlcy9AcHl0aG5ldHdvcmsvY2xpZW50L2xpYi9QeXRoQ29ubmVjdGlvbi5qcz9iMDZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHl0aENvbm5lY3Rpb24gPSB2b2lkIDA7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xudmFyIE9ORVMgPSAnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnO1xuLyoqXG4gKiBSZWFkcyBQeXRoIHByaWNlIGRhdGEgZnJvbSBhIHNvbGFuYSB3ZWIzIGNvbm5lY3Rpb24uIFRoaXMgY2xhc3MgdXNlcyBhIGNhbGxiYWNrLWRyaXZlbiBtb2RlbCxcbiAqIHNpbWlsYXIgdG8gdGhlIHNvbGFuYSB3ZWIzIG1ldGhvZHMgZm9yIHRyYWNraW5nIHVwZGF0ZXMgdG8gYWNjb3VudHMuXG4gKi9cbnZhciBQeXRoQ29ubmVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQ3JlYXRlIGEgUHl0aENvbm5lY3Rpb24gdGhhdCByZWFkcyBpdHMgZGF0YSBmcm9tIGFuIHVuZGVybHlpbmcgc29sYW5hIHdlYjMgY29ubmVjdGlvbi5cbiAgICAgKiAgcHl0aFByb2dyYW1LZXkgaXMgdGhlIHB1YmxpYyBrZXkgb2YgdGhlIFB5dGggcHJvZ3JhbSBydW5uaW5nIG9uIHRoZSBjaG9zZW4gc29sYW5hIGNsdXN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHl0aENvbm5lY3Rpb24oY29ubmVjdGlvbiwgcHl0aFByb2dyYW1LZXksIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgaWYgKGNvbW1pdG1lbnQgPT09IHZvaWQgMCkgeyBjb21taXRtZW50ID0gJ2ZpbmFsaXplZCc7IH1cbiAgICAgICAgdGhpcy5wcm9kdWN0QWNjb3VudEtleVRvUHJvZHVjdCA9IHt9O1xuICAgICAgICB0aGlzLnByaWNlQWNjb3VudEtleVRvUHJvZHVjdEFjY291bnRLZXkgPSB7fTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5weXRoUHJvZ3JhbUtleSA9IHB5dGhQcm9ncmFtS2V5O1xuICAgICAgICB0aGlzLmNvbW1pdG1lbnQgPSBjb21taXRtZW50O1xuICAgIH1cbiAgICBQeXRoQ29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlUHJvZHVjdEFjY291bnQgPSBmdW5jdGlvbiAoa2V5LCBhY2NvdW50KSB7XG4gICAgICAgIHZhciBfYSA9IGluZGV4XzEucGFyc2VQcm9kdWN0RGF0YShhY2NvdW50LmRhdGEpLCBwcmljZUFjY291bnRLZXkgPSBfYS5wcmljZUFjY291bnRLZXksIHR5cGUgPSBfYS50eXBlLCBwcm9kdWN0ID0gX2EucHJvZHVjdDtcbiAgICAgICAgdGhpcy5wcm9kdWN0QWNjb3VudEtleVRvUHJvZHVjdFtrZXkudG9TdHJpbmcoKV0gPSBwcm9kdWN0O1xuICAgICAgICBpZiAocHJpY2VBY2NvdW50S2V5LnRvU3RyaW5nKCkgIT09IE9ORVMpIHtcbiAgICAgICAgICAgIHRoaXMucHJpY2VBY2NvdW50S2V5VG9Qcm9kdWN0QWNjb3VudEtleVtwcmljZUFjY291bnRLZXkudG9TdHJpbmcoKV0gPSBrZXkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHl0aENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVByaWNlQWNjb3VudCA9IGZ1bmN0aW9uIChrZXksIGFjY291bnQpIHtcbiAgICAgICAgdmFyIHByb2R1Y3QgPSB0aGlzLnByb2R1Y3RBY2NvdW50S2V5VG9Qcm9kdWN0W3RoaXMucHJpY2VBY2NvdW50S2V5VG9Qcm9kdWN0QWNjb3VudEtleVtrZXkudG9TdHJpbmcoKV1dO1xuICAgICAgICBpZiAocHJvZHVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gc2luY2Ugd2UncmUgc3Vic2NyaWJlZCB0byBhbGwgb2YgdGhlIHByb2dyYW0ncyBhY2NvdW50cyxcbiAgICAgICAgICAgIC8vIGJ1dCBsZXQncyBiZSBnb29kIGRlZmVuc2l2ZSBwcm9ncmFtbWVycy5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR290IGEgcHJpY2UgdXBkYXRlIGZvciBhbiB1bmtub3duIHByb2R1Y3QuIFRoaXMgaXMgYSBidWcgaW4gdGhlIGxpYnJhcnksIHBsZWFzZSByZXBvcnQgaXQgdG8gdGhlIGRldmVsb3BlcnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByaWNlRGF0YSA9IGluZGV4XzEucGFyc2VQcmljZURhdGEoYWNjb3VudC5kYXRhKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2FsbGJhY2tzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX2FbX2ldO1xuICAgICAgICAgICAgY2FsbGJhY2socHJvZHVjdCwgcHJpY2VEYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHl0aENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZUFjY291bnQgPSBmdW5jdGlvbiAoa2V5LCBhY2NvdW50LCBwcm9kdWN0T25seSkge1xuICAgICAgICB2YXIgYmFzZSA9IGluZGV4XzEucGFyc2VCYXNlRGF0YShhY2NvdW50LmRhdGEpO1xuICAgICAgICAvLyBUaGUgcHl0aCBwcm9ncmFtIG93bnMgYWNjb3VudHMgdGhhdCBkb24ndCBjb250YWluIHB5dGggZGF0YSwgd2hpY2ggd2UgY2FuIHNhZmVseSBpZ25vcmUuXG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGluZGV4XzEuQWNjb3VudFR5cGVbYmFzZS50eXBlXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ01hcHBpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gc2tpcCB0aGVzZSBiZWNhdXNlIHdlJ3JlIGdvaW5nIHRvIGdldCBldmVyeSBhY2NvdW50IG93bmVkIGJ5IHRoaXMgcHJvZ3JhbSBhbnl3YXkuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1Byb2R1Y3QnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVByb2R1Y3RBY2NvdW50KGtleSwgYWNjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1ByaWNlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9kdWN0T25seSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQcmljZUFjY291bnQoa2V5LCBhY2NvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdUZXN0JzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhY2NvdW50IHR5cGU6IFwiICsgYmFzZS50eXBlICsgXCIuIFRyeSB1cGdyYWRpbmcgcHl0aC1jbGllbnQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogU3RhcnQgcmVjZWl2aW5nIHByaWNlIHVwZGF0ZXMuIE9uY2UgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCBhbnkgcmVnaXN0ZXJlZCBjYWxsYmFja3Mgd2lsbCBiZSBpbnZva2VkXG4gICAgICogIGVhY2ggdGltZSBhIFB5dGggcHJpY2UgYWNjb3VudCBpcyB1cGRhdGVkLlxuICAgICAqL1xuICAgIFB5dGhDb25uZWN0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFjY291bnRzLCBfaSwgYWNjb3VudHNfMSwgYWNjb3VudDtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY29ubmVjdGlvbi5nZXRQcm9ncmFtQWNjb3VudHModGhpcy5weXRoUHJvZ3JhbUtleSwgdGhpcy5jb21taXRtZW50KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIGFjY291bnRzXzEgPSBhY2NvdW50czsgX2kgPCBhY2NvdW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnQgPSBhY2NvdW50c18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUFjY291bnQoYWNjb3VudC5wdWJrZXksIGFjY291bnQuYWNjb3VudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub25Qcm9ncmFtQWNjb3VudENoYW5nZSh0aGlzLnB5dGhQcm9ncmFtS2V5LCBmdW5jdGlvbiAoa2V5ZWRBY2NvdW50SW5mbywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUFjY291bnQoa2V5ZWRBY2NvdW50SW5mby5hY2NvdW50SWQsIGtleWVkQWNjb3VudEluZm8uYWNjb3VudEluZm8sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuY29tbWl0bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJlZ2lzdGVyIGNhbGxiYWNrIHRvIHJlY2VpdmUgcHJpY2UgdXBkYXRlcy4gKi9cbiAgICBQeXRoQ29ubmVjdGlvbi5wcm90b3R5cGUub25QcmljZUNoYW5nZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8qKiBTdG9wIHJlY2VpdmluZyBwcmljZSB1cGRhdGVzLiBOb3RlIHRoYXQgdGhpcyBhbHNvIGN1cnJlbnRseSBkZWxldGVzIGFsbCByZWdpc3RlcmVkIGNhbGxiYWNrcy4gKi9cbiAgICBQeXRoQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gd2F5IHRvIGFjdHVhbGx5IHR1cm4gb2ZmIHRoZSBzb2xhbmEgd2ViMyBzdWJzY3JpcHRpb24geF94LCBidXQgdGhlcmUgc2hvdWxkIGJlLlxuICAgICAgICAgICAgICAgIC8vIExlYXZlIHRoaXMgbWV0aG9kIGluIHNvIHdlIGRvbid0IGhhdmUgdG8gdXBkYXRlIG91ciBBUEkgd2hlbiBzb2xhbmEgZml4ZXMgdGhlaXJzLlxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBpbnRlcmltLCBkZWxldGUgY2FsbGJhY2tzLlxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFB5dGhDb25uZWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuUHl0aENvbm5lY3Rpb24gPSBQeXRoQ29ubmVjdGlvbjtcbiJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuIiwidiIsIm9wIiwiVHlwZUVycm9yIiwiY2FsbCIsInBvcCIsImxlbmd0aCIsInB1c2giLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJQeXRoQ29ubmVjdGlvbiIsImluZGV4XzEiLCJyZXF1aXJlIiwiT05FUyIsImNvbm5lY3Rpb24iLCJweXRoUHJvZ3JhbUtleSIsImNvbW1pdG1lbnQiLCJwcm9kdWN0QWNjb3VudEtleVRvUHJvZHVjdCIsInByaWNlQWNjb3VudEtleVRvUHJvZHVjdEFjY291bnRLZXkiLCJjYWxsYmFja3MiLCJwcm90b3R5cGUiLCJoYW5kbGVQcm9kdWN0QWNjb3VudCIsImtleSIsImFjY291bnQiLCJfYSIsInBhcnNlUHJvZHVjdERhdGEiLCJkYXRhIiwicHJpY2VBY2NvdW50S2V5IiwidHlwZSIsInByb2R1Y3QiLCJ0b1N0cmluZyIsImhhbmRsZVByaWNlQWNjb3VudCIsInVuZGVmaW5lZCIsIkVycm9yIiwicHJpY2VEYXRhIiwicGFyc2VQcmljZURhdGEiLCJfaSIsImNhbGxiYWNrIiwiaGFuZGxlQWNjb3VudCIsInByb2R1Y3RPbmx5IiwiYmFzZSIsInBhcnNlQmFzZURhdGEiLCJBY2NvdW50VHlwZSIsInN0YXJ0IiwiYWNjb3VudHMiLCJhY2NvdW50c18xIiwiX3RoaXMiLCJnZXRQcm9ncmFtQWNjb3VudHMiLCJwdWJrZXkiLCJvblByb2dyYW1BY2NvdW50Q2hhbmdlIiwia2V5ZWRBY2NvdW50SW5mbyIsImNvbnRleHQiLCJhY2NvdW50SWQiLCJhY2NvdW50SW5mbyIsIm9uUHJpY2VDaGFuZ2UiLCJzdG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pythnetwork/client/lib/PythConnection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pythnetwork/client/lib/PythHttpClient.js":
/*!****************************************************************!*\
  !*** ./node_modules/@pythnetwork/client/lib/PythHttpClient.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (void 0) && (void 0).__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PythHttpClient = void 0;\nvar _1 = __webpack_require__(/*! . */ \"(ssr)/./node_modules/@pythnetwork/client/lib/index.js\");\n/**\n * Reads Pyth price data from a solana web3 connection. This class uses a single HTTP call.\n * Use the method getData() to get updated prices values.\n */ var PythHttpClient = /** @class */ function() {\n    function PythHttpClient(connection, pythProgramKey, commitment) {\n        if (commitment === void 0) {\n            commitment = \"finalized\";\n        }\n        this.connection = connection;\n        this.pythProgramKey = pythProgramKey;\n        this.commitment = commitment;\n    }\n    /*\n    * Get Pyth Network account information and return actual price state.\n    * The result contains lists of asset types, product symbols and their prices.\n    */ PythHttpClient.prototype.getData = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var assetTypes, productSymbols, products, productFromSymbol, productPrice, prices, accountList, priceDataQueue, productAccountKeyToProduct, result;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        assetTypes = new Set();\n                        productSymbols = new Set();\n                        products = new Set();\n                        productFromSymbol = new Map();\n                        productPrice = new Map();\n                        prices = new Array();\n                        return [\n                            4 /*yield*/ ,\n                            this.connection.getProgramAccounts(this.pythProgramKey, this.commitment)\n                        ];\n                    case 1:\n                        accountList = _a.sent();\n                        priceDataQueue = new Array();\n                        productAccountKeyToProduct = new Map();\n                        accountList.forEach(function(singleAccount) {\n                            var base = _1.parseBaseData(singleAccount.account.data);\n                            if (base) {\n                                switch(_1.AccountType[base.type]){\n                                    case \"Mapping\":\n                                        break;\n                                    case \"Product\":\n                                        var productData = _1.parseProductData(singleAccount.account.data);\n                                        productAccountKeyToProduct.set(singleAccount.pubkey.toBase58(), productData.product);\n                                        assetTypes.add(productData.product.asset_type);\n                                        productSymbols.add(productData.product.symbol);\n                                        products.add(productData.product);\n                                        productFromSymbol.set(productData.product.symbol, productData.product);\n                                        break;\n                                    case \"Price\":\n                                        var priceData = _1.parsePriceData(singleAccount.account.data);\n                                        priceDataQueue.push(priceData);\n                                        break;\n                                    case \"Test\":\n                                        break;\n                                    default:\n                                        throw new Error(\"Unknown account type: \" + base.type + \". Try upgrading pyth-client.\");\n                                }\n                            }\n                        });\n                        priceDataQueue.forEach(function(priceData) {\n                            var product = productAccountKeyToProduct.get(priceData.productAccountKey.toBase58());\n                            if (product) {\n                                productPrice.set(product.symbol, priceData);\n                                prices.push(priceData);\n                            }\n                        });\n                        result = {\n                            assetTypes: Array.from(assetTypes),\n                            symbols: Array.from(productSymbols),\n                            products: Array.from(products),\n                            productFromSymbol: productFromSymbol,\n                            productPrice: productPrice,\n                            prices: prices\n                        };\n                        return [\n                            2 /*return*/ ,\n                            result\n                        ];\n                }\n            });\n        });\n    };\n    return PythHttpClient;\n}();\nexports.PythHttpClient = PythHttpClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHB5dGhuZXR3b3JrL2NsaWVudC9saWIvUHl0aEh0dHBDbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNBLElBQUlPLGNBQWMsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxXQUFXLElBQUssU0FBVWxCLE9BQU8sRUFBRW1CLElBQUk7SUFDbkUsSUFBSUMsSUFBSTtRQUFFQyxPQUFPO1FBQUdDLE1BQU07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Q0FBQ0csTUFBTSxFQUFFUixZQUFZSyxPQUFPO3dDQUNyRTtvQ0FDSixLQUFLO3dDQUNELElBQUlJLFlBQVl0QyxHQUFHdUMsY0FBYyxDQUFDakIsY0FBY0csT0FBTyxDQUFDQyxJQUFJO3dDQUM1RFosZUFBZW5CLElBQUksQ0FBQzJDO3dDQUNwQjtvQ0FDSixLQUFLO3dDQUNEO29DQUNKO3dDQUNJLE1BQU0sSUFBSUUsTUFBTSwyQkFBMkJqQixLQUFLSyxJQUFJLEdBQUc7Z0NBQy9EOzRCQUNKO3dCQUNKO3dCQUNBZCxlQUFlTyxPQUFPLENBQUMsU0FBVWlCLFNBQVM7NEJBQ3RDLElBQUlKLFVBQVVuQiwyQkFBMkIwQixHQUFHLENBQUNILFVBQVVJLGlCQUFpQixDQUFDVCxRQUFROzRCQUNqRixJQUFJQyxTQUFTO2dDQUNUdkIsYUFBYW9CLEdBQUcsQ0FBQ0csUUFBUUcsTUFBTSxFQUFFQztnQ0FDakMxQixPQUFPakIsSUFBSSxDQUFDMkM7NEJBQ2hCO3dCQUNKO3dCQUNBcEUsU0FBUzs0QkFDTHFDLFlBQVlZLE1BQU13QixJQUFJLENBQUNwQzs0QkFDdkJxQyxTQUFTekIsTUFBTXdCLElBQUksQ0FBQ25DOzRCQUNwQkMsVUFBVVUsTUFBTXdCLElBQUksQ0FBQ2xDOzRCQUNyQkMsbUJBQW1CQTs0QkFDbkJDLGNBQWNBOzRCQUNkQyxRQUFRQTt3QkFDWjt3QkFDQSxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSTFDO3lCQUFPO2dCQUNyQztZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU82QjtBQUNYO0FBQ0FELHNCQUFzQixHQUFHQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaWZ0LXRyYWRpbmctdWkvLi9ub2RlX21vZHVsZXMvQHB5dGhuZXR3b3JrL2NsaWVudC9saWIvUHl0aEh0dHBDbGllbnQuanM/MDRlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlB5dGhIdHRwQ2xpZW50ID0gdm9pZCAwO1xudmFyIF8xID0gcmVxdWlyZShcIi5cIik7XG4vKipcbiAqIFJlYWRzIFB5dGggcHJpY2UgZGF0YSBmcm9tIGEgc29sYW5hIHdlYjMgY29ubmVjdGlvbi4gVGhpcyBjbGFzcyB1c2VzIGEgc2luZ2xlIEhUVFAgY2FsbC5cbiAqIFVzZSB0aGUgbWV0aG9kIGdldERhdGEoKSB0byBnZXQgdXBkYXRlZCBwcmljZXMgdmFsdWVzLlxuICovXG52YXIgUHl0aEh0dHBDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHl0aEh0dHBDbGllbnQoY29ubmVjdGlvbiwgcHl0aFByb2dyYW1LZXksIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgaWYgKGNvbW1pdG1lbnQgPT09IHZvaWQgMCkgeyBjb21taXRtZW50ID0gJ2ZpbmFsaXplZCc7IH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5weXRoUHJvZ3JhbUtleSA9IHB5dGhQcm9ncmFtS2V5O1xuICAgICAgICB0aGlzLmNvbW1pdG1lbnQgPSBjb21taXRtZW50O1xuICAgIH1cbiAgICAvKlxuICAgICogR2V0IFB5dGggTmV0d29yayBhY2NvdW50IGluZm9ybWF0aW9uIGFuZCByZXR1cm4gYWN0dWFsIHByaWNlIHN0YXRlLlxuICAgICogVGhlIHJlc3VsdCBjb250YWlucyBsaXN0cyBvZiBhc3NldCB0eXBlcywgcHJvZHVjdCBzeW1ib2xzIGFuZCB0aGVpciBwcmljZXMuXG4gICAgKi9cbiAgICBQeXRoSHR0cENsaWVudC5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFzc2V0VHlwZXMsIHByb2R1Y3RTeW1ib2xzLCBwcm9kdWN0cywgcHJvZHVjdEZyb21TeW1ib2wsIHByb2R1Y3RQcmljZSwgcHJpY2VzLCBhY2NvdW50TGlzdCwgcHJpY2VEYXRhUXVldWUsIHByb2R1Y3RBY2NvdW50S2V5VG9Qcm9kdWN0LCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NldFR5cGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFN5bWJvbHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RGcm9tU3ltYm9sID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFByaWNlID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2VzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNvbm5lY3Rpb24uZ2V0UHJvZ3JhbUFjY291bnRzKHRoaXMucHl0aFByb2dyYW1LZXksIHRoaXMuY29tbWl0bWVudCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50TGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlRGF0YVF1ZXVlID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0QWNjb3VudEtleVRvUHJvZHVjdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRMaXN0LmZvckVhY2goZnVuY3Rpb24gKHNpbmdsZUFjY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IF8xLnBhcnNlQmFzZURhdGEoc2luZ2xlQWNjb3VudC5hY2NvdW50LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoXzEuQWNjb3VudFR5cGVbYmFzZS50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTWFwcGluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHNraXAgdGhlc2UgYmVjYXVzZSB3ZSdyZSBnb2luZyB0byBnZXQgZXZlcnkgYWNjb3VudCBvd25lZCBieSB0aGlzIHByb2dyYW0gYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnUHJvZHVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb2R1Y3REYXRhID0gXzEucGFyc2VQcm9kdWN0RGF0YShzaW5nbGVBY2NvdW50LmFjY291bnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdEFjY291bnRLZXlUb1Byb2R1Y3Quc2V0KHNpbmdsZUFjY291bnQucHVia2V5LnRvQmFzZTU4KCksIHByb2R1Y3REYXRhLnByb2R1Y3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0VHlwZXMuYWRkKHByb2R1Y3REYXRhLnByb2R1Y3QuYXNzZXRfdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFN5bWJvbHMuYWRkKHByb2R1Y3REYXRhLnByb2R1Y3Quc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0cy5hZGQocHJvZHVjdERhdGEucHJvZHVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdEZyb21TeW1ib2wuc2V0KHByb2R1Y3REYXRhLnByb2R1Y3Quc3ltYm9sLCBwcm9kdWN0RGF0YS5wcm9kdWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1ByaWNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJpY2VEYXRhID0gXzEucGFyc2VQcmljZURhdGEoc2luZ2xlQWNjb3VudC5hY2NvdW50LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlRGF0YVF1ZXVlLnB1c2gocHJpY2VEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1Rlc3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFjY291bnQgdHlwZTogXCIgKyBiYXNlLnR5cGUgKyBcIi4gVHJ5IHVwZ3JhZGluZyBweXRoLWNsaWVudC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlRGF0YVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHByaWNlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9kdWN0ID0gcHJvZHVjdEFjY291bnRLZXlUb1Byb2R1Y3QuZ2V0KHByaWNlRGF0YS5wcm9kdWN0QWNjb3VudEtleS50b0Jhc2U1OCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvZHVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0UHJpY2Uuc2V0KHByb2R1Y3Quc3ltYm9sLCBwcmljZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmljZXMucHVzaChwcmljZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0VHlwZXM6IEFycmF5LmZyb20oYXNzZXRUeXBlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sczogQXJyYXkuZnJvbShwcm9kdWN0U3ltYm9scyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdHM6IEFycmF5LmZyb20ocHJvZHVjdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RGcm9tU3ltYm9sOiBwcm9kdWN0RnJvbVN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0UHJpY2U6IHByb2R1Y3RQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmljZXM6IHByaWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQeXRoSHR0cENsaWVudDtcbn0oKSk7XG5leHBvcnRzLlB5dGhIdHRwQ2xpZW50ID0gUHl0aEh0dHBDbGllbnQ7XG4iXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19nZW5lcmF0b3IiLCJib2R5IiwiXyIsImxhYmVsIiwic2VudCIsInQiLCJ0cnlzIiwib3BzIiwiZiIsInkiLCJnIiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsInYiLCJvcCIsIlR5cGVFcnJvciIsImNhbGwiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiUHl0aEh0dHBDbGllbnQiLCJfMSIsInJlcXVpcmUiLCJjb25uZWN0aW9uIiwicHl0aFByb2dyYW1LZXkiLCJjb21taXRtZW50IiwicHJvdG90eXBlIiwiZ2V0RGF0YSIsImFzc2V0VHlwZXMiLCJwcm9kdWN0U3ltYm9scyIsInByb2R1Y3RzIiwicHJvZHVjdEZyb21TeW1ib2wiLCJwcm9kdWN0UHJpY2UiLCJwcmljZXMiLCJhY2NvdW50TGlzdCIsInByaWNlRGF0YVF1ZXVlIiwicHJvZHVjdEFjY291bnRLZXlUb1Byb2R1Y3QiLCJfYSIsIlNldCIsIk1hcCIsIkFycmF5IiwiZ2V0UHJvZ3JhbUFjY291bnRzIiwiZm9yRWFjaCIsInNpbmdsZUFjY291bnQiLCJiYXNlIiwicGFyc2VCYXNlRGF0YSIsImFjY291bnQiLCJkYXRhIiwiQWNjb3VudFR5cGUiLCJ0eXBlIiwicHJvZHVjdERhdGEiLCJwYXJzZVByb2R1Y3REYXRhIiwic2V0IiwicHVia2V5IiwidG9CYXNlNTgiLCJwcm9kdWN0IiwiYWRkIiwiYXNzZXRfdHlwZSIsInN5bWJvbCIsInByaWNlRGF0YSIsInBhcnNlUHJpY2VEYXRhIiwiRXJyb3IiLCJnZXQiLCJwcm9kdWN0QWNjb3VudEtleSIsImZyb20iLCJzeW1ib2xzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pythnetwork/client/lib/PythHttpClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pythnetwork/client/lib/cluster.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pythnetwork/client/lib/cluster.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getPythProgramKeyForCluster = void 0;\nvar web3_js_1 = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/** Mapping from solana clusters to the public key of the pyth program. */ var clusterToPythProgramKey = {\n    \"mainnet-beta\": \"FsJ3A3u2vn5cTVofAjvy6y5kwABJAqYWpe4975bi2epH\",\n    devnet: \"gSbePebfvPy7tRqimPoVecS2UsBvYv46ynrzWocc92s\",\n    testnet: \"8tfDNiaEyrV6Q1U4DEXrEigs9DoDtkugzFbybENEbCDz\"\n};\n/** Gets the public key of the Pyth program running on the given cluster. */ function getPythProgramKeyForCluster(cluster) {\n    if (clusterToPythProgramKey[cluster] !== undefined) {\n        return new web3_js_1.PublicKey(clusterToPythProgramKey[cluster]);\n    } else {\n        throw new Error(\"Invalid Solana cluster name: \" + cluster + \". Valid options are: \" + JSON.stringify(Object.keys(clusterToPythProgramKey)));\n    }\n}\nexports.getPythProgramKeyForCluster = getPythProgramKeyForCluster;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHB5dGhuZXR3b3JrL2NsaWVudC9saWIvY2x1c3Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUNBQW1DLEdBQUcsS0FBSztBQUMzQyxJQUFJRyxZQUFZQyxtQkFBT0EsQ0FBQyw4RUFBaUI7QUFDekMsd0VBQXdFLEdBQ3hFLElBQUlDLDBCQUEwQjtJQUMxQixnQkFBZ0I7SUFDaEJDLFFBQVE7SUFDUkMsU0FBUztBQUNiO0FBQ0EsMEVBQTBFLEdBQzFFLFNBQVNMLDRCQUE0Qk0sT0FBTztJQUN4QyxJQUFJSCx1QkFBdUIsQ0FBQ0csUUFBUSxLQUFLQyxXQUFXO1FBQ2hELE9BQU8sSUFBSU4sVUFBVU8sU0FBUyxDQUFDTCx1QkFBdUIsQ0FBQ0csUUFBUTtJQUNuRSxPQUNLO1FBQ0QsTUFBTSxJQUFJRyxNQUFNLGtDQUFrQ0gsVUFBVSwwQkFBMEJJLEtBQUtDLFNBQVMsQ0FBQ2YsT0FBT2dCLElBQUksQ0FBQ1Q7SUFDckg7QUFDSjtBQUNBTCxtQ0FBbUMsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kcmlmdC10cmFkaW5nLXVpLy4vbm9kZV9tb2R1bGVzL0BweXRobmV0d29yay9jbGllbnQvbGliL2NsdXN0ZXIuanM/NDhlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UHl0aFByb2dyYW1LZXlGb3JDbHVzdGVyID0gdm9pZCAwO1xudmFyIHdlYjNfanNfMSA9IHJlcXVpcmUoXCJAc29sYW5hL3dlYjMuanNcIik7XG4vKiogTWFwcGluZyBmcm9tIHNvbGFuYSBjbHVzdGVycyB0byB0aGUgcHVibGljIGtleSBvZiB0aGUgcHl0aCBwcm9ncmFtLiAqL1xudmFyIGNsdXN0ZXJUb1B5dGhQcm9ncmFtS2V5ID0ge1xuICAgICdtYWlubmV0LWJldGEnOiAnRnNKM0EzdTJ2bjVjVFZvZkFqdnk2eTVrd0FCSkFxWVdwZTQ5NzViaTJlcEgnLFxuICAgIGRldm5ldDogJ2dTYmVQZWJmdlB5N3RScWltUG9WZWNTMlVzQnZZdjQ2eW5yeldvY2M5MnMnLFxuICAgIHRlc3RuZXQ6ICc4dGZETmlhRXlyVjZRMVU0REVYckVpZ3M5RG9EdGt1Z3pGYnliRU5FYkNEeicsXG59O1xuLyoqIEdldHMgdGhlIHB1YmxpYyBrZXkgb2YgdGhlIFB5dGggcHJvZ3JhbSBydW5uaW5nIG9uIHRoZSBnaXZlbiBjbHVzdGVyLiAqL1xuZnVuY3Rpb24gZ2V0UHl0aFByb2dyYW1LZXlGb3JDbHVzdGVyKGNsdXN0ZXIpIHtcbiAgICBpZiAoY2x1c3RlclRvUHl0aFByb2dyYW1LZXlbY2x1c3Rlcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IHdlYjNfanNfMS5QdWJsaWNLZXkoY2x1c3RlclRvUHl0aFByb2dyYW1LZXlbY2x1c3Rlcl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTb2xhbmEgY2x1c3RlciBuYW1lOiBcIiArIGNsdXN0ZXIgKyBcIi4gVmFsaWQgb3B0aW9ucyBhcmU6IFwiICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoY2x1c3RlclRvUHl0aFByb2dyYW1LZXkpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRQeXRoUHJvZ3JhbUtleUZvckNsdXN0ZXIgPSBnZXRQeXRoUHJvZ3JhbUtleUZvckNsdXN0ZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRQeXRoUHJvZ3JhbUtleUZvckNsdXN0ZXIiLCJ3ZWIzX2pzXzEiLCJyZXF1aXJlIiwiY2x1c3RlclRvUHl0aFByb2dyYW1LZXkiLCJkZXZuZXQiLCJ0ZXN0bmV0IiwiY2x1c3RlciIsInVuZGVmaW5lZCIsIlB1YmxpY0tleSIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pythnetwork/client/lib/cluster.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pythnetwork/client/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@pythnetwork/client/lib/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getPythProgramKeyForCluster = exports.PythHttpClient = exports.PythConnection = exports.parsePriceData = exports.parseProductData = exports.parseMappingData = exports.parseBaseData = exports.MAX_SLOT_DIFFERENCE = exports.AccountType = exports.DeriveType = exports.PriceType = exports.CorpAction = exports.PriceStatus = exports.Version = exports.Version2 = exports.Magic = void 0;\nvar web3_js_1 = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\nvar buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nvar readBig_1 = __webpack_require__(/*! ./readBig */ \"(ssr)/./node_modules/@pythnetwork/client/lib/readBig.js\");\n/** Constants. This section must be kept in sync with the on-chain program. */ exports.Magic = 0xa1b2c3d4;\nexports.Version2 = 2;\nexports.Version = exports.Version2;\nexports.PriceStatus = [\n    \"Unknown\",\n    \"Trading\",\n    \"Halted\",\n    \"Auction\"\n];\nexports.CorpAction = [\n    \"NoCorpAct\"\n];\nexports.PriceType = [\n    \"Unknown\",\n    \"Price\"\n];\nexports.DeriveType = [\n    \"Unknown\",\n    \"TWAP\",\n    \"Volatility\"\n];\nexports.AccountType = [\n    \"Unknown\",\n    \"Mapping\",\n    \"Product\",\n    \"Price\",\n    \"Test\"\n];\n/** Number of slots that can pass before a publisher's price is no longer included in the aggregate. */ exports.MAX_SLOT_DIFFERENCE = 25;\nvar empty32Buffer = buffer_1.Buffer.alloc(32);\nvar PKorNull = function(data) {\n    return data.equals(empty32Buffer) ? null : new web3_js_1.PublicKey(data);\n};\n/** Parse data as a generic Pyth account. Use this method if you don't know the account type. */ function parseBaseData(data) {\n    // data is too short to have the magic number.\n    if (data.byteLength < 4) {\n        return undefined;\n    }\n    var magic = data.readUInt32LE(0);\n    if (magic === exports.Magic) {\n        // program version\n        var version = data.readUInt32LE(4);\n        // account type\n        var type = data.readUInt32LE(8);\n        // account used size\n        var size = data.readUInt32LE(12);\n        return {\n            magic: magic,\n            version: version,\n            type: type,\n            size: size\n        };\n    } else {\n        return undefined;\n    }\n}\nexports.parseBaseData = parseBaseData;\nvar parseMappingData = function(data) {\n    // pyth magic number\n    var magic = data.readUInt32LE(0);\n    // program version\n    var version = data.readUInt32LE(4);\n    // account type\n    var type = data.readUInt32LE(8);\n    // account used size\n    var size = data.readUInt32LE(12);\n    // number of product accounts\n    var numProducts = data.readUInt32LE(16);\n    // unused\n    // const unused = accountInfo.data.readUInt32LE(20)\n    // next mapping account (if any)\n    var nextMappingAccount = PKorNull(data.slice(24, 56));\n    // read each symbol account\n    var offset = 56;\n    var productAccountKeys = [];\n    for(var i = 0; i < numProducts; i++){\n        var productAccountBytes = data.slice(offset, offset + 32);\n        var productAccountKey = new web3_js_1.PublicKey(productAccountBytes);\n        offset += 32;\n        productAccountKeys.push(productAccountKey);\n    }\n    return {\n        magic: magic,\n        version: version,\n        type: type,\n        size: size,\n        nextMappingAccount: nextMappingAccount,\n        productAccountKeys: productAccountKeys\n    };\n};\nexports.parseMappingData = parseMappingData;\nvar parseProductData = function(data) {\n    // pyth magic number\n    var magic = data.readUInt32LE(0);\n    // program version\n    var version = data.readUInt32LE(4);\n    // account type\n    var type = data.readUInt32LE(8);\n    // price account size\n    var size = data.readUInt32LE(12);\n    // first price account in list\n    var priceAccountBytes = data.slice(16, 48);\n    var priceAccountKey = new web3_js_1.PublicKey(priceAccountBytes);\n    var product = {};\n    var idx = 48;\n    while(idx < size){\n        var keyLength = data[idx];\n        idx++;\n        if (keyLength) {\n            var key = data.slice(idx, idx + keyLength).toString();\n            idx += keyLength;\n            var valueLength = data[idx];\n            idx++;\n            var value = data.slice(idx, idx + valueLength).toString();\n            idx += valueLength;\n            product[key] = value;\n        }\n    }\n    return {\n        magic: magic,\n        version: version,\n        type: type,\n        size: size,\n        priceAccountKey: priceAccountKey,\n        product: product\n    };\n};\nexports.parseProductData = parseProductData;\nvar parseEma = function(data, exponent) {\n    // current value of ema\n    var valueComponent = readBig_1.readBigInt64LE(data, 0);\n    var value = Number(valueComponent) * Math.pow(10, exponent);\n    // numerator state for next update\n    var numerator = readBig_1.readBigInt64LE(data, 8);\n    // denominator state for next update\n    var denominator = readBig_1.readBigInt64LE(data, 16);\n    return {\n        valueComponent: valueComponent,\n        value: value,\n        numerator: numerator,\n        denominator: denominator\n    };\n};\nvar parsePriceInfo = function(data, exponent) {\n    // aggregate price\n    var priceComponent = readBig_1.readBigInt64LE(data, 0);\n    var price = Number(priceComponent) * Math.pow(10, exponent);\n    // aggregate confidence\n    var confidenceComponent = readBig_1.readBigUInt64LE(data, 8);\n    var confidence = Number(confidenceComponent) * Math.pow(10, exponent);\n    // aggregate status\n    var status = data.readUInt32LE(16);\n    // aggregate corporate action\n    var corporateAction = data.readUInt32LE(20);\n    // aggregate publish slot\n    var publishSlot = readBig_1.readBigUInt64LE(data, 24);\n    return {\n        priceComponent: priceComponent,\n        price: price,\n        confidenceComponent: confidenceComponent,\n        confidence: confidence,\n        status: status,\n        corporateAction: corporateAction,\n        publishSlot: publishSlot\n    };\n};\nvar parsePriceData = function(data) {\n    // pyth magic number\n    var magic = data.readUInt32LE(0);\n    // program version\n    var version = data.readUInt32LE(4);\n    // account type\n    var type = data.readUInt32LE(8);\n    // price account size\n    var size = data.readUInt32LE(12);\n    // price or calculation type\n    var priceType = data.readUInt32LE(16);\n    // price exponent\n    var exponent = data.readInt32LE(20);\n    // number of component prices\n    var numComponentPrices = data.readUInt32LE(24);\n    // number of quoters that make up aggregate\n    var numQuoters = data.readUInt32LE(28);\n    // slot of last valid (not unknown) aggregate price\n    var lastSlot = readBig_1.readBigUInt64LE(data, 32);\n    // valid on-chain slot of aggregate price\n    var validSlot = readBig_1.readBigUInt64LE(data, 40);\n    // time-weighted average price\n    var twap = parseEma(data.slice(48, 72), exponent);\n    // time-weighted average confidence interval\n    var twac = parseEma(data.slice(72, 96), exponent);\n    // space for future derived values\n    var drv1Component = readBig_1.readBigInt64LE(data, 96);\n    var drv1 = Number(drv1Component) * Math.pow(10, exponent);\n    // minimum number of publishers for status to be TRADING\n    var minPublishers = data.readUInt8(104);\n    // space for future derived values\n    var drv2 = data.readInt8(105);\n    // space for future derived values\n    var drv3 = data.readInt16LE(106);\n    // space for future derived values\n    var drv4 = data.readInt32LE(108);\n    // product id / reference account\n    var productAccountKey = new web3_js_1.PublicKey(data.slice(112, 144));\n    // next price account in list\n    var nextPriceAccountKey = PKorNull(data.slice(144, 176));\n    // valid slot of previous update\n    var previousSlot = readBig_1.readBigUInt64LE(data, 176);\n    // aggregate price of previous update\n    var previousPriceComponent = readBig_1.readBigInt64LE(data, 184);\n    var previousPrice = Number(previousPriceComponent) * Math.pow(10, exponent);\n    // confidence interval of previous update\n    var previousConfidenceComponent = readBig_1.readBigUInt64LE(data, 192);\n    var previousConfidence = Number(previousConfidenceComponent) * Math.pow(10, exponent);\n    // space for future derived values\n    var drv5Component = readBig_1.readBigInt64LE(data, 200);\n    var drv5 = Number(drv5Component) * Math.pow(10, exponent);\n    var aggregate = parsePriceInfo(data.slice(208, 240), exponent);\n    var price;\n    var confidence;\n    if (aggregate.status === 1) {\n        price = aggregate.price;\n        confidence = aggregate.confidence;\n    }\n    // price components - up to 32\n    var priceComponents = [];\n    var offset = 240;\n    var shouldContinue = true;\n    while(offset < data.length && shouldContinue){\n        var publisher = PKorNull(data.slice(offset, offset + 32));\n        offset += 32;\n        if (publisher) {\n            var componentAggregate = parsePriceInfo(data.slice(offset, offset + 32), exponent);\n            offset += 32;\n            var latest = parsePriceInfo(data.slice(offset, offset + 32), exponent);\n            offset += 32;\n            priceComponents.push({\n                publisher: publisher,\n                aggregate: componentAggregate,\n                latest: latest\n            });\n        } else {\n            shouldContinue = false;\n        }\n    }\n    return {\n        magic: magic,\n        version: version,\n        type: type,\n        size: size,\n        priceType: priceType,\n        exponent: exponent,\n        numComponentPrices: numComponentPrices,\n        numQuoters: numQuoters,\n        lastSlot: lastSlot,\n        validSlot: validSlot,\n        twap: twap,\n        twac: twac,\n        drv1Component: drv1Component,\n        drv1: drv1,\n        minPublishers: minPublishers,\n        drv2: drv2,\n        drv3: drv3,\n        drv4: drv4,\n        productAccountKey: productAccountKey,\n        nextPriceAccountKey: nextPriceAccountKey,\n        previousSlot: previousSlot,\n        previousPriceComponent: previousPriceComponent,\n        previousPrice: previousPrice,\n        previousConfidenceComponent: previousConfidenceComponent,\n        previousConfidence: previousConfidence,\n        drv5Component: drv5Component,\n        drv5: drv5,\n        aggregate: aggregate,\n        priceComponents: priceComponents,\n        price: price,\n        confidence: confidence\n    };\n};\nexports.parsePriceData = parsePriceData;\nvar PythConnection_1 = __webpack_require__(/*! ./PythConnection */ \"(ssr)/./node_modules/@pythnetwork/client/lib/PythConnection.js\");\nObject.defineProperty(exports, \"PythConnection\", ({\n    enumerable: true,\n    get: function() {\n        return PythConnection_1.PythConnection;\n    }\n}));\nvar PythHttpClient_1 = __webpack_require__(/*! ./PythHttpClient */ \"(ssr)/./node_modules/@pythnetwork/client/lib/PythHttpClient.js\");\nObject.defineProperty(exports, \"PythHttpClient\", ({\n    enumerable: true,\n    get: function() {\n        return PythHttpClient_1.PythHttpClient;\n    }\n}));\nvar cluster_1 = __webpack_require__(/*! ./cluster */ \"(ssr)/./node_modules/@pythnetwork/client/lib/cluster.js\");\nObject.defineProperty(exports, \"getPythProgramKeyForCluster\", ({\n    enumerable: true,\n    get: function() {\n        return cluster_1.getPythProgramKeyForCluster;\n    }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHB5dGhuZXR3b3JrL2NsaWVudC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1DQUFtQyxHQUFHQSxzQkFBc0IsR0FBR0Esc0JBQXNCLEdBQUdBLHNCQUFzQixHQUFHQSx3QkFBd0IsR0FBR0Esd0JBQXdCLEdBQUdBLHFCQUFxQixHQUFHQSwyQkFBMkIsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHQSxpQkFBaUIsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSxlQUFlLEdBQUdBLGdCQUFnQixHQUFHQSxhQUFhLEdBQUcsS0FBSztBQUNqWSxJQUFJa0IsWUFBWUMsbUJBQU9BLENBQUMsOEVBQWlCO0FBQ3pDLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CLElBQUlFLFlBQVlGLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLDRFQUE0RSxHQUM1RW5CLGFBQWEsR0FBRztBQUNoQkEsZ0JBQWdCLEdBQUc7QUFDbkJBLGVBQWUsR0FBR0EsUUFBUWdCLFFBQVE7QUFDbENoQixtQkFBbUIsR0FBRztJQUFDO0lBQVc7SUFBVztJQUFVO0NBQVU7QUFDakVBLGtCQUFrQixHQUFHO0lBQUM7Q0FBWTtBQUNsQ0EsaUJBQWlCLEdBQUc7SUFBQztJQUFXO0NBQVE7QUFDeENBLGtCQUFrQixHQUFHO0lBQUM7SUFBVztJQUFRO0NBQWE7QUFDdERBLG1CQUFtQixHQUFHO0lBQUM7SUFBVztJQUFXO0lBQVc7SUFBUztDQUFPO0FBQ3hFLHFHQUFxRyxHQUNyR0EsMkJBQTJCLEdBQUc7QUFDOUIsSUFBSXNCLGdCQUFnQkYsU0FBU0csTUFBTSxDQUFDQyxLQUFLLENBQUM7QUFDMUMsSUFBSUMsV0FBVyxTQUFVQyxJQUFJO0lBQUksT0FBUUEsS0FBS0MsTUFBTSxDQUFDTCxpQkFBaUIsT0FBTyxJQUFJSixVQUFVVSxTQUFTLENB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QUFtQnBGLG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNqRHJCLGtEQUFpRDtJQUFFMEcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsaUJBQWlCbkcsY0FBYztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BJLElBQUlzRyxtQkFBbUJ2RixtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDakRyQixrREFBaUQ7SUFBRTBHLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLGlCQUFpQnZHLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNwSSxJQUFJd0csWUFBWXhGLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DckIsK0RBQThEO0lBQUUwRyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxVQUFVekcsMkJBQTJCO0lBQUU7QUFBRSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kcmlmdC10cmFkaW5nLXVpLy4vbm9kZV9tb2R1bGVzL0BweXRobmV0d29yay9jbGllbnQvbGliL2luZGV4LmpzP2NiMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFB5dGhQcm9ncmFtS2V5Rm9yQ2x1c3RlciA9IGV4cG9ydHMuUHl0aEh0dHBDbGllbnQgPSBleHBvcnRzLlB5dGhDb25uZWN0aW9uID0gZXhwb3J0cy5wYXJzZVByaWNlRGF0YSA9IGV4cG9ydHMucGFyc2VQcm9kdWN0RGF0YSA9IGV4cG9ydHMucGFyc2VNYXBwaW5nRGF0YSA9IGV4cG9ydHMucGFyc2VCYXNlRGF0YSA9IGV4cG9ydHMuTUFYX1NMT1RfRElGRkVSRU5DRSA9IGV4cG9ydHMuQWNjb3VudFR5cGUgPSBleHBvcnRzLkRlcml2ZVR5cGUgPSBleHBvcnRzLlByaWNlVHlwZSA9IGV4cG9ydHMuQ29ycEFjdGlvbiA9IGV4cG9ydHMuUHJpY2VTdGF0dXMgPSBleHBvcnRzLlZlcnNpb24gPSBleHBvcnRzLlZlcnNpb24yID0gZXhwb3J0cy5NYWdpYyA9IHZvaWQgMDtcbnZhciB3ZWIzX2pzXzEgPSByZXF1aXJlKFwiQHNvbGFuYS93ZWIzLmpzXCIpO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbnZhciByZWFkQmlnXzEgPSByZXF1aXJlKFwiLi9yZWFkQmlnXCIpO1xuLyoqIENvbnN0YW50cy4gVGhpcyBzZWN0aW9uIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIG9uLWNoYWluIHByb2dyYW0uICovXG5leHBvcnRzLk1hZ2ljID0gMHhhMWIyYzNkNDtcbmV4cG9ydHMuVmVyc2lvbjIgPSAyO1xuZXhwb3J0cy5WZXJzaW9uID0gZXhwb3J0cy5WZXJzaW9uMjtcbmV4cG9ydHMuUHJpY2VTdGF0dXMgPSBbJ1Vua25vd24nLCAnVHJhZGluZycsICdIYWx0ZWQnLCAnQXVjdGlvbiddO1xuZXhwb3J0cy5Db3JwQWN0aW9uID0gWydOb0NvcnBBY3QnXTtcbmV4cG9ydHMuUHJpY2VUeXBlID0gWydVbmtub3duJywgJ1ByaWNlJ107XG5leHBvcnRzLkRlcml2ZVR5cGUgPSBbJ1Vua25vd24nLCAnVFdBUCcsICdWb2xhdGlsaXR5J107XG5leHBvcnRzLkFjY291bnRUeXBlID0gWydVbmtub3duJywgJ01hcHBpbmcnLCAnUHJvZHVjdCcsICdQcmljZScsICdUZXN0J107XG4vKiogTnVtYmVyIG9mIHNsb3RzIHRoYXQgY2FuIHBhc3MgYmVmb3JlIGEgcHVibGlzaGVyJ3MgcHJpY2UgaXMgbm8gbG9uZ2VyIGluY2x1ZGVkIGluIHRoZSBhZ2dyZWdhdGUuICovXG5leHBvcnRzLk1BWF9TTE9UX0RJRkZFUkVOQ0UgPSAyNTtcbnZhciBlbXB0eTMyQnVmZmVyID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDMyKTtcbnZhciBQS29yTnVsbCA9IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiAoZGF0YS5lcXVhbHMoZW1wdHkzMkJ1ZmZlcikgPyBudWxsIDogbmV3IHdlYjNfanNfMS5QdWJsaWNLZXkoZGF0YSkpOyB9O1xuLyoqIFBhcnNlIGRhdGEgYXMgYSBnZW5lcmljIFB5dGggYWNjb3VudC4gVXNlIHRoaXMgbWV0aG9kIGlmIHlvdSBkb24ndCBrbm93IHRoZSBhY2NvdW50IHR5cGUuICovXG5mdW5jdGlvbiBwYXJzZUJhc2VEYXRhKGRhdGEpIHtcbiAgICAvLyBkYXRhIGlzIHRvbyBzaG9ydCB0byBoYXZlIHRoZSBtYWdpYyBudW1iZXIuXG4gICAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA8IDQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIG1hZ2ljID0gZGF0YS5yZWFkVUludDMyTEUoMCk7XG4gICAgaWYgKG1hZ2ljID09PSBleHBvcnRzLk1hZ2ljKSB7XG4gICAgICAgIC8vIHByb2dyYW0gdmVyc2lvblxuICAgICAgICB2YXIgdmVyc2lvbiA9IGRhdGEucmVhZFVJbnQzMkxFKDQpO1xuICAgICAgICAvLyBhY2NvdW50IHR5cGVcbiAgICAgICAgdmFyIHR5cGUgPSBkYXRhLnJlYWRVSW50MzJMRSg4KTtcbiAgICAgICAgLy8gYWNjb3VudCB1c2VkIHNpemVcbiAgICAgICAgdmFyIHNpemUgPSBkYXRhLnJlYWRVSW50MzJMRSgxMik7XG4gICAgICAgIHJldHVybiB7IG1hZ2ljOiBtYWdpYywgdmVyc2lvbjogdmVyc2lvbiwgdHlwZTogdHlwZSwgc2l6ZTogc2l6ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLnBhcnNlQmFzZURhdGEgPSBwYXJzZUJhc2VEYXRhO1xudmFyIHBhcnNlTWFwcGluZ0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIHB5dGggbWFnaWMgbnVtYmVyXG4gICAgdmFyIG1hZ2ljID0gZGF0YS5yZWFkVUludDMyTEUoMCk7XG4gICAgLy8gcHJvZ3JhbSB2ZXJzaW9uXG4gICAgdmFyIHZlcnNpb24gPSBkYXRhLnJlYWRVSW50MzJMRSg0KTtcbiAgICAvLyBhY2NvdW50IHR5cGVcbiAgICB2YXIgdHlwZSA9IGRhdGEucmVhZFVJbnQzMkxFKDgpO1xuICAgIC8vIGFjY291bnQgdXNlZCBzaXplXG4gICAgdmFyIHNpemUgPSBkYXRhLnJlYWRVSW50MzJMRSgxMik7XG4gICAgLy8gbnVtYmVyIG9mIHByb2R1Y3QgYWNjb3VudHNcbiAgICB2YXIgbnVtUHJvZHVjdHMgPSBkYXRhLnJlYWRVSW50MzJMRSgxNik7XG4gICAgLy8gdW51c2VkXG4gICAgLy8gY29uc3QgdW51c2VkID0gYWNjb3VudEluZm8uZGF0YS5yZWFkVUludDMyTEUoMjApXG4gICAgLy8gbmV4dCBtYXBwaW5nIGFjY291bnQgKGlmIGFueSlcbiAgICB2YXIgbmV4dE1hcHBpbmdBY2NvdW50ID0gUEtvck51bGwoZGF0YS5zbGljZSgyNCwgNTYpKTtcbiAgICAvLyByZWFkIGVhY2ggc3ltYm9sIGFjY291bnRcbiAgICB2YXIgb2Zmc2V0ID0gNTY7XG4gICAgdmFyIHByb2R1Y3RBY2NvdW50S2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUHJvZHVjdHM7IGkrKykge1xuICAgICAgICB2YXIgcHJvZHVjdEFjY291bnRCeXRlcyA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzMik7XG4gICAgICAgIHZhciBwcm9kdWN0QWNjb3VudEtleSA9IG5ldyB3ZWIzX2pzXzEuUHVibGljS2V5KHByb2R1Y3RBY2NvdW50Qnl0ZXMpO1xuICAgICAgICBvZmZzZXQgKz0gMzI7XG4gICAgICAgIHByb2R1Y3RBY2NvdW50S2V5cy5wdXNoKHByb2R1Y3RBY2NvdW50S2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFnaWM6IG1hZ2ljLFxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBuZXh0TWFwcGluZ0FjY291bnQ6IG5leHRNYXBwaW5nQWNjb3VudCxcbiAgICAgICAgcHJvZHVjdEFjY291bnRLZXlzOiBwcm9kdWN0QWNjb3VudEtleXMsXG4gICAgfTtcbn07XG5leHBvcnRzLnBhcnNlTWFwcGluZ0RhdGEgPSBwYXJzZU1hcHBpbmdEYXRhO1xudmFyIHBhcnNlUHJvZHVjdERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIHB5dGggbWFnaWMgbnVtYmVyXG4gICAgdmFyIG1hZ2ljID0gZGF0YS5yZWFkVUludDMyTEUoMCk7XG4gICAgLy8gcHJvZ3JhbSB2ZXJzaW9uXG4gICAgdmFyIHZlcnNpb24gPSBkYXRhLnJlYWRVSW50MzJMRSg0KTtcbiAgICAvLyBhY2NvdW50IHR5cGVcbiAgICB2YXIgdHlwZSA9IGRhdGEucmVhZFVJbnQzMkxFKDgpO1xuICAgIC8vIHByaWNlIGFjY291bnQgc2l6ZVxuICAgIHZhciBzaXplID0gZGF0YS5yZWFkVUludDMyTEUoMTIpO1xuICAgIC8vIGZpcnN0IHByaWNlIGFjY291bnQgaW4gbGlzdFxuICAgIHZhciBwcmljZUFjY291bnRCeXRlcyA9IGRhdGEuc2xpY2UoMTYsIDQ4KTtcbiAgICB2YXIgcHJpY2VBY2NvdW50S2V5ID0gbmV3IHdlYjNfanNfMS5QdWJsaWNLZXkocHJpY2VBY2NvdW50Qnl0ZXMpO1xuICAgIHZhciBwcm9kdWN0ID0ge307XG4gICAgdmFyIGlkeCA9IDQ4O1xuICAgIHdoaWxlIChpZHggPCBzaXplKSB7XG4gICAgICAgIHZhciBrZXlMZW5ndGggPSBkYXRhW2lkeF07XG4gICAgICAgIGlkeCsrO1xuICAgICAgICBpZiAoa2V5TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZGF0YS5zbGljZShpZHgsIGlkeCArIGtleUxlbmd0aCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlkeCArPSBrZXlMZW5ndGg7XG4gICAgICAgICAgICB2YXIgdmFsdWVMZW5ndGggPSBkYXRhW2lkeF07XG4gICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGEuc2xpY2UoaWR4LCBpZHggKyB2YWx1ZUxlbmd0aCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlkeCArPSB2YWx1ZUxlbmd0aDtcbiAgICAgICAgICAgIHByb2R1Y3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1hZ2ljOiBtYWdpYywgdmVyc2lvbjogdmVyc2lvbiwgdHlwZTogdHlwZSwgc2l6ZTogc2l6ZSwgcHJpY2VBY2NvdW50S2V5OiBwcmljZUFjY291bnRLZXksIHByb2R1Y3Q6IHByb2R1Y3QgfTtcbn07XG5leHBvcnRzLnBhcnNlUHJvZHVjdERhdGEgPSBwYXJzZVByb2R1Y3REYXRhO1xudmFyIHBhcnNlRW1hID0gZnVuY3Rpb24gKGRhdGEsIGV4cG9uZW50KSB7XG4gICAgLy8gY3VycmVudCB2YWx1ZSBvZiBlbWFcbiAgICB2YXIgdmFsdWVDb21wb25lbnQgPSByZWFkQmlnXzEucmVhZEJpZ0ludDY0TEUoZGF0YSwgMCk7XG4gICAgdmFyIHZhbHVlID0gTnVtYmVyKHZhbHVlQ29tcG9uZW50KSAqIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG4gICAgLy8gbnVtZXJhdG9yIHN0YXRlIGZvciBuZXh0IHVwZGF0ZVxuICAgIHZhciBudW1lcmF0b3IgPSByZWFkQmlnXzEucmVhZEJpZ0ludDY0TEUoZGF0YSwgOCk7XG4gICAgLy8gZGVub21pbmF0b3Igc3RhdGUgZm9yIG5leHQgdXBkYXRlXG4gICAgdmFyIGRlbm9taW5hdG9yID0gcmVhZEJpZ18xLnJlYWRCaWdJbnQ2NExFKGRhdGEsIDE2KTtcbiAgICByZXR1cm4geyB2YWx1ZUNvbXBvbmVudDogdmFsdWVDb21wb25lbnQsIHZhbHVlOiB2YWx1ZSwgbnVtZXJhdG9yOiBudW1lcmF0b3IsIGRlbm9taW5hdG9yOiBkZW5vbWluYXRvciB9O1xufTtcbnZhciBwYXJzZVByaWNlSW5mbyA9IGZ1bmN0aW9uIChkYXRhLCBleHBvbmVudCkge1xuICAgIC8vIGFnZ3JlZ2F0ZSBwcmljZVxuICAgIHZhciBwcmljZUNvbXBvbmVudCA9IHJlYWRCaWdfMS5yZWFkQmlnSW50NjRMRShkYXRhLCAwKTtcbiAgICB2YXIgcHJpY2UgPSBOdW1iZXIocHJpY2VDb21wb25lbnQpICogTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcbiAgICAvLyBhZ2dyZWdhdGUgY29uZmlkZW5jZVxuICAgIHZhciBjb25maWRlbmNlQ29tcG9uZW50ID0gcmVhZEJpZ18xLnJlYWRCaWdVSW50NjRMRShkYXRhLCA4KTtcbiAgICB2YXIgY29uZmlkZW5jZSA9IE51bWJlcihjb25maWRlbmNlQ29tcG9uZW50KSAqIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG4gICAgLy8gYWdncmVnYXRlIHN0YXR1c1xuICAgIHZhciBzdGF0dXMgPSBkYXRhLnJlYWRVSW50MzJMRSgxNik7XG4gICAgLy8gYWdncmVnYXRlIGNvcnBvcmF0ZSBhY3Rpb25cbiAgICB2YXIgY29ycG9yYXRlQWN0aW9uID0gZGF0YS5yZWFkVUludDMyTEUoMjApO1xuICAgIC8vIGFnZ3JlZ2F0ZSBwdWJsaXNoIHNsb3RcbiAgICB2YXIgcHVibGlzaFNsb3QgPSByZWFkQmlnXzEucmVhZEJpZ1VJbnQ2NExFKGRhdGEsIDI0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmljZUNvbXBvbmVudDogcHJpY2VDb21wb25lbnQsXG4gICAgICAgIHByaWNlOiBwcmljZSxcbiAgICAgICAgY29uZmlkZW5jZUNvbXBvbmVudDogY29uZmlkZW5jZUNvbXBvbmVudCxcbiAgICAgICAgY29uZmlkZW5jZTogY29uZmlkZW5jZSxcbiAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgIGNvcnBvcmF0ZUFjdGlvbjogY29ycG9yYXRlQWN0aW9uLFxuICAgICAgICBwdWJsaXNoU2xvdDogcHVibGlzaFNsb3QsXG4gICAgfTtcbn07XG52YXIgcGFyc2VQcmljZURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIC8vIHB5dGggbWFnaWMgbnVtYmVyXG4gICAgdmFyIG1hZ2ljID0gZGF0YS5yZWFkVUludDMyTEUoMCk7XG4gICAgLy8gcHJvZ3JhbSB2ZXJzaW9uXG4gICAgdmFyIHZlcnNpb24gPSBkYXRhLnJlYWRVSW50MzJMRSg0KTtcbiAgICAvLyBhY2NvdW50IHR5cGVcbiAgICB2YXIgdHlwZSA9IGRhdGEucmVhZFVJbnQzMkxFKDgpO1xuICAgIC8vIHByaWNlIGFjY291bnQgc2l6ZVxuICAgIHZhciBzaXplID0gZGF0YS5yZWFkVUludDMyTEUoMTIpO1xuICAgIC8vIHByaWNlIG9yIGNhbGN1bGF0aW9uIHR5cGVcbiAgICB2YXIgcHJpY2VUeXBlID0gZGF0YS5yZWFkVUludDMyTEUoMTYpO1xuICAgIC8vIHByaWNlIGV4cG9uZW50XG4gICAgdmFyIGV4cG9uZW50ID0gZGF0YS5yZWFkSW50MzJMRSgyMCk7XG4gICAgLy8gbnVtYmVyIG9mIGNvbXBvbmVudCBwcmljZXNcbiAgICB2YXIgbnVtQ29tcG9uZW50UHJpY2VzID0gZGF0YS5yZWFkVUludDMyTEUoMjQpO1xuICAgIC8vIG51bWJlciBvZiBxdW90ZXJzIHRoYXQgbWFrZSB1cCBhZ2dyZWdhdGVcbiAgICB2YXIgbnVtUXVvdGVycyA9IGRhdGEucmVhZFVJbnQzMkxFKDI4KTtcbiAgICAvLyBzbG90IG9mIGxhc3QgdmFsaWQgKG5vdCB1bmtub3duKSBhZ2dyZWdhdGUgcHJpY2VcbiAgICB2YXIgbGFzdFNsb3QgPSByZWFkQmlnXzEucmVhZEJpZ1VJbnQ2NExFKGRhdGEsIDMyKTtcbiAgICAvLyB2YWxpZCBvbi1jaGFpbiBzbG90IG9mIGFnZ3JlZ2F0ZSBwcmljZVxuICAgIHZhciB2YWxpZFNsb3QgPSByZWFkQmlnXzEucmVhZEJpZ1VJbnQ2NExFKGRhdGEsIDQwKTtcbiAgICAvLyB0aW1lLXdlaWdodGVkIGF2ZXJhZ2UgcHJpY2VcbiAgICB2YXIgdHdhcCA9IHBhcnNlRW1hKGRhdGEuc2xpY2UoNDgsIDcyKSwgZXhwb25lbnQpO1xuICAgIC8vIHRpbWUtd2VpZ2h0ZWQgYXZlcmFnZSBjb25maWRlbmNlIGludGVydmFsXG4gICAgdmFyIHR3YWMgPSBwYXJzZUVtYShkYXRhLnNsaWNlKDcyLCA5NiksIGV4cG9uZW50KTtcbiAgICAvLyBzcGFjZSBmb3IgZnV0dXJlIGRlcml2ZWQgdmFsdWVzXG4gICAgdmFyIGRydjFDb21wb25lbnQgPSByZWFkQmlnXzEucmVhZEJpZ0ludDY0TEUoZGF0YSwgOTYpO1xuICAgIHZhciBkcnYxID0gTnVtYmVyKGRydjFDb21wb25lbnQpICogTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcbiAgICAvLyBtaW5pbXVtIG51bWJlciBvZiBwdWJsaXNoZXJzIGZvciBzdGF0dXMgdG8gYmUgVFJBRElOR1xuICAgIHZhciBtaW5QdWJsaXNoZXJzID0gZGF0YS5yZWFkVUludDgoMTA0KTtcbiAgICAvLyBzcGFjZSBmb3IgZnV0dXJlIGRlcml2ZWQgdmFsdWVzXG4gICAgdmFyIGRydjIgPSBkYXRhLnJlYWRJbnQ4KDEwNSk7XG4gICAgLy8gc3BhY2UgZm9yIGZ1dHVyZSBkZXJpdmVkIHZhbHVlc1xuICAgIHZhciBkcnYzID0gZGF0YS5yZWFkSW50MTZMRSgxMDYpO1xuICAgIC8vIHNwYWNlIGZvciBmdXR1cmUgZGVyaXZlZCB2YWx1ZXNcbiAgICB2YXIgZHJ2NCA9IGRhdGEucmVhZEludDMyTEUoMTA4KTtcbiAgICAvLyBwcm9kdWN0IGlkIC8gcmVmZXJlbmNlIGFjY291bnRcbiAgICB2YXIgcHJvZHVjdEFjY291bnRLZXkgPSBuZXcgd2ViM19qc18xLlB1YmxpY0tleShkYXRhLnNsaWNlKDExMiwgMTQ0KSk7XG4gICAgLy8gbmV4dCBwcmljZSBhY2NvdW50IGluIGxpc3RcbiAgICB2YXIgbmV4dFByaWNlQWNjb3VudEtleSA9IFBLb3JOdWxsKGRhdGEuc2xpY2UoMTQ0LCAxNzYpKTtcbiAgICAvLyB2YWxpZCBzbG90IG9mIHByZXZpb3VzIHVwZGF0ZVxuICAgIHZhciBwcmV2aW91c1Nsb3QgPSByZWFkQmlnXzEucmVhZEJpZ1VJbnQ2NExFKGRhdGEsIDE3Nik7XG4gICAgLy8gYWdncmVnYXRlIHByaWNlIG9mIHByZXZpb3VzIHVwZGF0ZVxuICAgIHZhciBwcmV2aW91c1ByaWNlQ29tcG9uZW50ID0gcmVhZEJpZ18xLnJlYWRCaWdJbnQ2NExFKGRhdGEsIDE4NCk7XG4gICAgdmFyIHByZXZpb3VzUHJpY2UgPSBOdW1iZXIocHJldmlvdXNQcmljZUNvbXBvbmVudCkgKiBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuICAgIC8vIGNvbmZpZGVuY2UgaW50ZXJ2YWwgb2YgcHJldmlvdXMgdXBkYXRlXG4gICAgdmFyIHByZXZpb3VzQ29uZmlkZW5jZUNvbXBvbmVudCA9IHJlYWRCaWdfMS5yZWFkQmlnVUludDY0TEUoZGF0YSwgMTkyKTtcbiAgICB2YXIgcHJldmlvdXNDb25maWRlbmNlID0gTnVtYmVyKHByZXZpb3VzQ29uZmlkZW5jZUNvbXBvbmVudCkgKiBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuICAgIC8vIHNwYWNlIGZvciBmdXR1cmUgZGVyaXZlZCB2YWx1ZXNcbiAgICB2YXIgZHJ2NUNvbXBvbmVudCA9IHJlYWRCaWdfMS5yZWFkQmlnSW50NjRMRShkYXRhLCAyMDApO1xuICAgIHZhciBkcnY1ID0gTnVtYmVyKGRydjVDb21wb25lbnQpICogTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcbiAgICB2YXIgYWdncmVnYXRlID0gcGFyc2VQcmljZUluZm8oZGF0YS5zbGljZSgyMDgsIDI0MCksIGV4cG9uZW50KTtcbiAgICB2YXIgcHJpY2U7XG4gICAgdmFyIGNvbmZpZGVuY2U7XG4gICAgaWYgKGFnZ3JlZ2F0ZS5zdGF0dXMgPT09IDEpIHtcbiAgICAgICAgcHJpY2UgPSBhZ2dyZWdhdGUucHJpY2U7XG4gICAgICAgIGNvbmZpZGVuY2UgPSBhZ2dyZWdhdGUuY29uZmlkZW5jZTtcbiAgICB9XG4gICAgLy8gcHJpY2UgY29tcG9uZW50cyAtIHVwIHRvIDMyXG4gICAgdmFyIHByaWNlQ29tcG9uZW50cyA9IFtdO1xuICAgIHZhciBvZmZzZXQgPSAyNDA7XG4gICAgdmFyIHNob3VsZENvbnRpbnVlID0gdHJ1ZTtcbiAgICB3aGlsZSAob2Zmc2V0IDwgZGF0YS5sZW5ndGggJiYgc2hvdWxkQ29udGludWUpIHtcbiAgICAgICAgdmFyIHB1Ymxpc2hlciA9IFBLb3JOdWxsKGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzMikpO1xuICAgICAgICBvZmZzZXQgKz0gMzI7XG4gICAgICAgIGlmIChwdWJsaXNoZXIpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRBZ2dyZWdhdGUgPSBwYXJzZVByaWNlSW5mbyhkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMzIpLCBleHBvbmVudCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMzI7XG4gICAgICAgICAgICB2YXIgbGF0ZXN0ID0gcGFyc2VQcmljZUluZm8oZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKSwgZXhwb25lbnQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDMyO1xuICAgICAgICAgICAgcHJpY2VDb21wb25lbnRzLnB1c2goeyBwdWJsaXNoZXI6IHB1Ymxpc2hlciwgYWdncmVnYXRlOiBjb21wb25lbnRBZ2dyZWdhdGUsIGxhdGVzdDogbGF0ZXN0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2hvdWxkQ29udGludWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYWdpYzogbWFnaWMsXG4gICAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHByaWNlVHlwZTogcHJpY2VUeXBlLFxuICAgICAgICBleHBvbmVudDogZXhwb25lbnQsXG4gICAgICAgIG51bUNvbXBvbmVudFByaWNlczogbnVtQ29tcG9uZW50UHJpY2VzLFxuICAgICAgICBudW1RdW90ZXJzOiBudW1RdW90ZXJzLFxuICAgICAgICBsYXN0U2xvdDogbGFzdFNsb3QsXG4gICAgICAgIHZhbGlkU2xvdDogdmFsaWRTbG90LFxuICAgICAgICB0d2FwOiB0d2FwLFxuICAgICAgICB0d2FjOiB0d2FjLFxuICAgICAgICBkcnYxQ29tcG9uZW50OiBkcnYxQ29tcG9uZW50LFxuICAgICAgICBkcnYxOiBkcnYxLFxuICAgICAgICBtaW5QdWJsaXNoZXJzOiBtaW5QdWJsaXNoZXJzLFxuICAgICAgICBkcnYyOiBkcnYyLFxuICAgICAgICBkcnYzOiBkcnYzLFxuICAgICAgICBkcnY0OiBkcnY0LFxuICAgICAgICBwcm9kdWN0QWNjb3VudEtleTogcHJvZHVjdEFjY291bnRLZXksXG4gICAgICAgIG5leHRQcmljZUFjY291bnRLZXk6IG5leHRQcmljZUFjY291bnRLZXksXG4gICAgICAgIHByZXZpb3VzU2xvdDogcHJldmlvdXNTbG90LFxuICAgICAgICBwcmV2aW91c1ByaWNlQ29tcG9uZW50OiBwcmV2aW91c1ByaWNlQ29tcG9uZW50LFxuICAgICAgICBwcmV2aW91c1ByaWNlOiBwcmV2aW91c1ByaWNlLFxuICAgICAgICBwcmV2aW91c0NvbmZpZGVuY2VDb21wb25lbnQ6IHByZXZpb3VzQ29uZmlkZW5jZUNvbXBvbmVudCxcbiAgICAgICAgcHJldmlvdXNDb25maWRlbmNlOiBwcmV2aW91c0NvbmZpZGVuY2UsXG4gICAgICAgIGRydjVDb21wb25lbnQ6IGRydjVDb21wb25lbnQsXG4gICAgICAgIGRydjU6IGRydjUsXG4gICAgICAgIGFnZ3JlZ2F0ZTogYWdncmVnYXRlLFxuICAgICAgICBwcmljZUNvbXBvbmVudHM6IHByaWNlQ29tcG9uZW50cyxcbiAgICAgICAgcHJpY2U6IHByaWNlLFxuICAgICAgICBjb25maWRlbmNlOiBjb25maWRlbmNlLFxuICAgIH07XG59O1xuZXhwb3J0cy5wYXJzZVByaWNlRGF0YSA9IHBhcnNlUHJpY2VEYXRhO1xudmFyIFB5dGhDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9QeXRoQ29ubmVjdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlB5dGhDb25uZWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQeXRoQ29ubmVjdGlvbl8xLlB5dGhDb25uZWN0aW9uOyB9IH0pO1xudmFyIFB5dGhIdHRwQ2xpZW50XzEgPSByZXF1aXJlKFwiLi9QeXRoSHR0cENsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlB5dGhIdHRwQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQeXRoSHR0cENsaWVudF8xLlB5dGhIdHRwQ2xpZW50OyB9IH0pO1xudmFyIGNsdXN0ZXJfMSA9IHJlcXVpcmUoXCIuL2NsdXN0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQeXRoUHJvZ3JhbUtleUZvckNsdXN0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsdXN0ZXJfMS5nZXRQeXRoUHJvZ3JhbUtleUZvckNsdXN0ZXI7IH0gfSk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRQeXRoUHJvZ3JhbUtleUZvckNsdXN0ZXIiLCJQeXRoSHR0cENsaWVudCIsIlB5dGhDb25uZWN0aW9uIiwicGFyc2VQcmljZURhdGEiLCJwYXJzZVByb2R1Y3REYXRhIiwicGFyc2VNYXBwaW5nRGF0YSIsInBhcnNlQmFzZURhdGEiLCJNQVhfU0xPVF9ESUZGRVJFTkNFIiwiQWNjb3VudFR5cGUiLCJEZXJpdmVUeXBlIiwiUHJpY2VUeXBlIiwiQ29ycEFjdGlvbiIsIlByaWNlU3RhdHVzIiwiVmVyc2lvbiIsIlZlcnNpb24yIiwiTWFnaWMiLCJ3ZWIzX2pzXzEiLCJyZXF1aXJlIiwiYnVmZmVyXzEiLCJyZWFkQmlnXzEiLCJlbXB0eTMyQnVmZmVyIiwiQnVmZmVyIiwiYWxsb2MiLCJQS29yTnVsbCIsImRhdGEiLCJlcXVhbHMiLCJQdWJsaWNLZXkiLCJieXRlTGVuZ3RoIiwidW5kZWZpbmVkIiwibWFnaWMiLCJyZWFkVUludDMyTEUiLCJ2ZXJzaW9uIiwidHlwZSIsInNpemUiLCJudW1Qcm9kdWN0cyIsIm5leHRNYXBwaW5nQWNjb3VudCIsInNsaWNlIiwib2Zmc2V0IiwicHJvZHVjdEFjY291bnRLZXlzIiwiaSIsInByb2R1Y3RBY2NvdW50Qnl0ZXMiLCJwcm9kdWN0QWNjb3VudEtleSIsInB1c2giLCJwcmljZUFjY291bnRCeXRlcyIsInByaWNlQWNjb3VudEtleSIsInByb2R1Y3QiLCJpZHgiLCJrZXlMZW5ndGgiLCJrZXkiLCJ0b1N0cmluZyIsInZhbHVlTGVuZ3RoIiwicGFyc2VFbWEiLCJleHBvbmVudCIsInZhbHVlQ29tcG9uZW50IiwicmVhZEJpZ0ludDY0TEUiLCJOdW1iZXIiLCJNYXRoIiwicG93IiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJwYXJzZVByaWNlSW5mbyIsInByaWNlQ29tcG9uZW50IiwicHJpY2UiLCJjb25maWRlbmNlQ29tcG9uZW50IiwicmVhZEJpZ1VJbnQ2NExFIiwiY29uZmlkZW5jZSIsInN0YXR1cyIsImNvcnBvcmF0ZUFjdGlvbiIsInB1Ymxpc2hTbG90IiwicHJpY2VUeXBlIiwicmVhZEludDMyTEUiLCJudW1Db21wb25lbnRQcmljZXMiLCJudW1RdW90ZXJzIiwibGFzdFNsb3QiLCJ2YWxpZFNsb3QiLCJ0d2FwIiwidHdhYyIsImRydjFDb21wb25lbnQiLCJkcnYxIiwibWluUHVibGlzaGVycyIsInJlYWRVSW50OCIsImRydjIiLCJyZWFkSW50OCIsImRydjMiLCJyZWFkSW50MTZMRSIsImRydjQiLCJuZXh0UHJpY2VBY2NvdW50S2V5IiwicHJldmlvdXNTbG90IiwicHJldmlvdXNQcmljZUNvbXBvbmVudCIsInByZXZpb3VzUHJpY2UiLCJwcmV2aW91c0NvbmZpZGVuY2VDb21wb25lbnQiLCJwcmV2aW91c0NvbmZpZGVuY2UiLCJkcnY1Q29tcG9uZW50IiwiZHJ2NSIsImFnZ3JlZ2F0ZSIsInByaWNlQ29tcG9uZW50cyIsInNob3VsZENvbnRpbnVlIiwibGVuZ3RoIiwicHVibGlzaGVyIiwiY29tcG9uZW50QWdncmVnYXRlIiwibGF0ZXN0IiwiUHl0aENvbm5lY3Rpb25fMSIsImVudW1lcmFibGUiLCJnZXQiLCJQeXRoSHR0cENsaWVudF8xIiwiY2x1c3Rlcl8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pythnetwork/client/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@pythnetwork/client/lib/readBig.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pythnetwork/client/lib/readBig.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.readBigUInt64LE = exports.readBigInt64LE = void 0;\n// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/errors.js#L758\nvar ERR_BUFFER_OUT_OF_BOUNDS = function() {\n    return new Error(\"Attempt to access memory outside buffer bounds\");\n};\n// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/errors.js#L968\nvar ERR_INVALID_ARG_TYPE = function(name, expected, actual) {\n    return new Error('The \"' + name + '\" argument must be of type ' + expected + \". Received \" + actual);\n};\n// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/errors.js#L1262\nvar ERR_OUT_OF_RANGE = function(str, range, received) {\n    return new Error('The value of \"' + str + \" is out of range. It must be \" + range + \". Received \" + received);\n};\n// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/validators.js#L127-L130\nfunction validateNumber(value, name) {\n    if (typeof value !== \"number\") throw ERR_INVALID_ARG_TYPE(name, \"number\", value);\n}\n// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/buffer.js#L68-L80\nfunction boundsError(value, length) {\n    if (Math.floor(value) !== value) {\n        validateNumber(value, \"offset\");\n        throw ERR_OUT_OF_RANGE(\"offset\", \"an integer\", value);\n    }\n    if (length < 0) throw ERR_BUFFER_OUT_OF_BOUNDS();\n    throw ERR_OUT_OF_RANGE(\"offset\", \">= 0 and <= \" + length, value);\n}\n// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/buffer.js#L129-L145\nfunction readBigInt64LE(buffer, offset) {\n    if (offset === void 0) {\n        offset = 0;\n    }\n    validateNumber(offset, \"offset\");\n    var first = buffer[offset];\n    var last = buffer[offset + 7];\n    if (first === undefined || last === undefined) boundsError(offset, buffer.length - 8);\n    // tslint:disable-next-line:no-bitwise\n    var val = buffer[offset + 4] + buffer[offset + 5] * Math.pow(2, 8) + buffer[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow\n    return (BigInt(val) << BigInt(32)) + // tslint:disable-line:no-bitwise\n    BigInt(first + buffer[++offset] * Math.pow(2, 8) + buffer[++offset] * Math.pow(2, 16) + buffer[++offset] * Math.pow(2, 24));\n}\nexports.readBigInt64LE = readBigInt64LE;\n// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/buffer.js#L89-L107\nfunction readBigUInt64LE(buffer, offset) {\n    if (offset === void 0) {\n        offset = 0;\n    }\n    validateNumber(offset, \"offset\");\n    var first = buffer[offset];\n    var last = buffer[offset + 7];\n    if (first === undefined || last === undefined) boundsError(offset, buffer.length - 8);\n    var lo = first + buffer[++offset] * Math.pow(2, 8) + buffer[++offset] * Math.pow(2, 16) + buffer[++offset] * Math.pow(2, 24);\n    var hi = buffer[++offset] + buffer[++offset] * Math.pow(2, 8) + buffer[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);\n    return BigInt(lo) + (BigInt(hi) << BigInt(32)); // tslint:disable-line:no-bitwise\n}\nexports.readBigUInt64LE = readBigUInt64LE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHB5dGhuZXR3b3JrL2NsaWVudC9saWIvcmVhZEJpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDeEQsMkVBQTJFO0FBQzNFLElBQUlJLDJCQUEyQjtJQUFjLE9BQU8sSUFBSUMsTUFBTTtBQUFtRDtBQUNqSCwyRUFBMkU7QUFDM0UsSUFBSUMsdUJBQXVCLFNBQVVDLElBQUksRUFBRUMsUUFBUSxFQUFFQyxNQUFNO0lBQ3ZELE9BQU8sSUFBSUosTUFBTSxVQUFXRSxPQUFPLGdDQUFpQ0MsV0FBVyxnQkFBZ0JDO0FBQ25HO0FBQ0EsNEVBQTRFO0FBQzVFLElBQUlDLG1CQUFtQixTQUFVQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsUUFBUTtJQUNqRCxPQUFPLElBQUlSLE1BQU0sbUJBQW9CTSxNQUFNLGtDQUFrQ0MsUUFBUSxnQkFBZ0JDO0FBQ3pHO0FBQ0Esb0ZBQW9GO0FBQ3BGLFNBQVNDLGVBQWViLEtBQUssRUFBRU0sSUFBSTtJQUMvQixJQUFJLE9BQU9OLFVBQVUsVUFDakIsTUFBTUsscUJBQXFCQyxNQUFNLFVBQVVOO0FBQ25EO0FBQ0EsOEVBQThFO0FBQzlFLFNBQVNjLFlBQVlkLEtBQUssRUFBRWUsTUFBTTtJQUM5QixJQUFJQyxLQUFLQyxLQUFLLENBQUNqQixXQUFXQSxPQUFPO1FBQzdCYSxlQUFlYixPQUFPO1FBQ3RCLE1BQU1TLGlCQUFpQixVQUFVLGNBQWNUO0lBQ25EO0lBQ0EsSUFBSWUsU0FBUyxHQUNULE1BQU1aO0lBQ1YsTUFBTU0saUJBQWlCLFVBQVUsaUJBQWlCTSxRQUFRZjtBQUM5RDtBQUNBLGdGQUFnRjtBQUNoRixTQUFTRSxlQUFlZ0IsTUFBTSxFQUFFQyxNQUFNO0lBQ2xDLElBQUlBLFdBQVcsS0FBSyxHQUFHO1FBQUVBLFNBQVM7SUFBRztJQUNyQ04sZUFBZU0sUUFBUTtJQUN2QixJQUFJQyxRQUFRRixNQUFNLENBQUNDLE9BQU87SUFDMUIsSUFBSUUsT0FBT0gsTUFBTSxDQUFDQyxTQUFTLEVBQUU7SUFDN0IsSUFBSUMsVUFBVUUsYUFBYUQsU0FBU0MsV0FDaENSLFlBQVlLLFFBQVFELE9BQU9ILE1BQU0sR0FBRztJQUN4QyxzQ0FBc0M7SUFDdEMsSUFBSVEsTUFBTUwsTUFBTSxDQUFDQyxTQUFTLEVBQUUsR0FBR0QsTUFBTSxDQUFDQyxTQUFTLEVBQUUsR0FBR0gsS0FBS1EsR0FBRyxDQUFDLEdBQUcsS0FBS04sTUFBTSxDQUFDQyxTQUFTLEVBQUUsR0FBR0gsS0FBS1EsR0FBRyxDQUFDLEdBQUcsTUFBT0gsQ0FBQUEsUUFBUSxFQUFDLEdBQUksV0FBVztJQUNySSxPQUFRLENBQUNJLE9BQU9GLFFBQVFFLE9BQU8sR0FBRSxJQUFLLGlDQUFpQztJQUNuRUEsT0FBT0wsUUFBUUYsTUFBTSxDQUFDLEVBQUVDLE9BQU8sR0FBR0gsS0FBS1EsR0FBRyxDQUFDLEdBQUcsS0FBS04sTUFBTSxDQUFDLEVBQUVDLE9BQU8sR0FBR0gsS0FBS1EsR0FBRyxDQUFDLEdBQUcsTUFBTU4sTUFBTSxDQUFDLEVBQUVDLE9BQU8sR0FBR0gsS0FBS1EsR0FBRyxDQUFDLEdBQUc7QUFDL0g7QUFDQXpCLHNCQUFzQixHQUFHRztBQUN6QiwrRUFBK0U7QUFDL0UsU0FBU0QsZ0JBQWdCaUIsTUFBTSxFQUFFQyxNQUFNO0lBQ25DLElBQUlBLFdBQVcsS0FBSyxHQUFHO1FBQUVBLFNBQVM7SUFBRztJQUNyQ04sZUFBZU0sUUFBUTtJQUN2QixJQUFJQyxRQUFRRixNQUFNLENBQUNDLE9BQU87SUFDMUIsSUFBSUUsT0FBT0gsTUFBTSxDQUFDQyxTQUFTLEVBQUU7SUFDN0IsSUFBSUMsVUFBVUUsYUFBYUQsU0FBU0MsV0FDaENSLFlBQVlLLFFBQVFELE9BQU9ILE1BQU0sR0FBRztJQUN4QyxJQUFJVyxLQUFLTixRQUFRRixNQUFNLENBQUMsRUFBRUMsT0FBTyxHQUFHSCxLQUFLUSxHQUFHLENBQUMsR0FBRyxLQUFLTixNQUFNLENBQUMsRUFBRUMsT0FBTyxHQUFHSCxLQUFLUSxHQUFHLENBQUMsR0FBRyxNQUFNTixNQUFNLENBQUMsRUFBRUMsT0FBTyxHQUFHSCxLQUFLUSxHQUFHLENBQUMsR0FBRztJQUN6SCxJQUFJRyxLQUFLVCxNQUFNLENBQUMsRUFBRUMsT0FBTyxHQUFHRCxNQUFNLENBQUMsRUFBRUMsT0FBTyxHQUFHSCxLQUFLUSxHQUFHLENBQUMsR0FBRyxLQUFLTixNQUFNLENBQUMsRUFBRUMsT0FBTyxHQUFHSCxLQUFLUSxHQUFHLENBQUMsR0FBRyxNQUFNSCxPQUFPTCxLQUFLUSxHQUFHLENBQUMsR0FBRztJQUN4SCxPQUFPQyxPQUFPQyxNQUFPRCxDQUFBQSxPQUFPRSxPQUFPRixPQUFPLEdBQUUsR0FBSSxpQ0FBaUM7QUFDckY7QUFDQTFCLHVCQUF1QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2RyaWZ0LXRyYWRpbmctdWkvLi9ub2RlX21vZHVsZXMvQHB5dGhuZXR3b3JrL2NsaWVudC9saWIvcmVhZEJpZy5qcz81ZDA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWFkQmlnVUludDY0TEUgPSBleHBvcnRzLnJlYWRCaWdJbnQ2NExFID0gdm9pZCAwO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjE0LjE3LjAvbGliL2ludGVybmFsL2Vycm9ycy5qcyNMNzU4XG52YXIgRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVycm9yKCdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJyk7IH07XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTQuMTcuMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzI0w5NjhcbnZhciBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIlRoZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBcIiArIGV4cGVjdGVkICsgXCIuIFJlY2VpdmVkIFwiICsgYWN0dWFsKTtcbn07XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTQuMTcuMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzI0wxMjYyXG52YXIgRVJSX09VVF9PRl9SQU5HRSA9IGZ1bmN0aW9uIChzdHIsIHJhbmdlLCByZWNlaXZlZCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJUaGUgdmFsdWUgb2YgXFxcIlwiICsgc3RyICsgXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIFwiICsgcmFuZ2UgKyBcIi4gUmVjZWl2ZWQgXCIgKyByZWNlaXZlZCk7XG59O1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjE0LjE3LjAvbGliL2ludGVybmFsL3ZhbGlkYXRvcnMuanMjTDEyNy1MMTMwXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpO1xufVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjE0LjE3LjAvbGliL2ludGVybmFsL2J1ZmZlci5qcyNMNjgtTDgwXG5mdW5jdGlvbiBib3VuZHNFcnJvcih2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgICAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgJ29mZnNldCcpO1xuICAgICAgICB0aHJvdyBFUlJfT1VUX09GX1JBTkdFKCdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCA8IDApXG4gICAgICAgIHRocm93IEVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpO1xuICAgIHRocm93IEVSUl9PVVRfT0ZfUkFOR0UoJ29mZnNldCcsIFwiPj0gMCBhbmQgPD0gXCIgKyBsZW5ndGgsIHZhbHVlKTtcbn1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxNC4xNy4wL2xpYi9pbnRlcm5hbC9idWZmZXIuanMjTDEyOS1MMTQ1XG5mdW5jdGlvbiByZWFkQmlnSW50NjRMRShidWZmZXIsIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gICAgdmFyIGZpcnN0ID0gYnVmZmVyW29mZnNldF07XG4gICAgdmFyIGxhc3QgPSBidWZmZXJbb2Zmc2V0ICsgN107XG4gICAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1ZmZlci5sZW5ndGggLSA4KTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxuICAgIHZhciB2YWwgPSBidWZmZXJbb2Zmc2V0ICsgNF0gKyBidWZmZXJbb2Zmc2V0ICsgNV0gKiBNYXRoLnBvdygyLCA4KSArIGJ1ZmZlcltvZmZzZXQgKyA2XSAqIE1hdGgucG93KDIsIDE2KSArIChsYXN0IDw8IDI0KTsgLy8gT3ZlcmZsb3dcbiAgICByZXR1cm4gKChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArIC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tYml0d2lzZVxuICAgICAgICBCaWdJbnQoZmlyc3QgKyBidWZmZXJbKytvZmZzZXRdICogTWF0aC5wb3coMiwgOCkgKyBidWZmZXJbKytvZmZzZXRdICogTWF0aC5wb3coMiwgMTYpICsgYnVmZmVyWysrb2Zmc2V0XSAqIE1hdGgucG93KDIsIDI0KSkpO1xufVxuZXhwb3J0cy5yZWFkQmlnSW50NjRMRSA9IHJlYWRCaWdJbnQ2NExFO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjE0LjE3LjAvbGliL2ludGVybmFsL2J1ZmZlci5qcyNMODktTDEwN1xuZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKTtcbiAgICB2YXIgZmlyc3QgPSBidWZmZXJbb2Zmc2V0XTtcbiAgICB2YXIgbGFzdCA9IGJ1ZmZlcltvZmZzZXQgKyA3XTtcbiAgICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmZmVyLmxlbmd0aCAtIDgpO1xuICAgIHZhciBsbyA9IGZpcnN0ICsgYnVmZmVyWysrb2Zmc2V0XSAqIE1hdGgucG93KDIsIDgpICsgYnVmZmVyWysrb2Zmc2V0XSAqIE1hdGgucG93KDIsIDE2KSArIGJ1ZmZlclsrK29mZnNldF0gKiBNYXRoLnBvdygyLCAyNCk7XG4gICAgdmFyIGhpID0gYnVmZmVyWysrb2Zmc2V0XSArIGJ1ZmZlclsrK29mZnNldF0gKiBNYXRoLnBvdygyLCA4KSArIGJ1ZmZlclsrK29mZnNldF0gKiBNYXRoLnBvdygyLCAxNikgKyBsYXN0ICogTWF0aC5wb3coMiwgMjQpO1xuICAgIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tYml0d2lzZVxufVxuZXhwb3J0cy5yZWFkQmlnVUludDY0TEUgPSByZWFkQmlnVUludDY0TEU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZWFkQmlnVUludDY0TEUiLCJyZWFkQmlnSW50NjRMRSIsIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsIkVycm9yIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJuYW1lIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJFUlJfT1VUX09GX1JBTkdFIiwic3RyIiwicmFuZ2UiLCJyZWNlaXZlZCIsInZhbGlkYXRlTnVtYmVyIiwiYm91bmRzRXJyb3IiLCJsZW5ndGgiLCJNYXRoIiwiZmxvb3IiLCJidWZmZXIiLCJvZmZzZXQiLCJmaXJzdCIsImxhc3QiLCJ1bmRlZmluZWQiLCJ2YWwiLCJwb3ciLCJCaWdJbnQiLCJsbyIsImhpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@pythnetwork/client/lib/readBig.js\n");

/***/ })

};
;