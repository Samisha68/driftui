"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/DriftClientProvider.tsx":
/*!********************************************!*\
  !*** ./components/DriftClientProvider.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DriftClientProvider: function() { return /* binding */ DriftClientProvider; },\n/* harmony export */   useDriftClient: function() { return /* binding */ useDriftClient; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _drift_labs_sdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @drift-labs/sdk */ \"(app-pages-browser)/./node_modules/@drift-labs/sdk/lib/index.js\");\n/* harmony import */ var _drift_labs_sdk__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_drift_labs_sdk__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ DriftClientProvider,useDriftClient auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n// Custom error for rate limiting\nclass RateLimitError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"RateLimitError\";\n    }\n}\nconst DriftClientContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    driftClient: null,\n    userAccounts: null,\n    error: null,\n    isLoading: true,\n    isConnected: false,\n    isSubscribed: false,\n    currentRpcEndpoint: null\n});\n// Define multiple RPC endpoints - Prioritize public Solana endpoint\nconst RPC_ENDPOINTS = [\n    \"https://api.devnet.solana.com\",\n    \"https://devnet.helius-rpc.com/?api-key=76547270-226d-446d-8293-c1b3f8e8ea1b\" || 0\n].filter(Boolean); // Filter out any potential undefined/null values\n_c = RPC_ENDPOINTS;\nconst MAX_RETRIES_PER_ENDPOINT = 5; // Max retries for non-rate-limit errors per endpoint\nconst INITIAL_RETRY_DELAY = 5000; // 5 seconds for regular errors\nconst MAX_RETRY_DELAY = 30000; // 30 seconds for regular errors\nconst ENDPOINT_SWITCH_DELAY = 1000; // Short delay before trying next endpoint\nconst sleep = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\nconst getJitter = (baseDelay)=>{\n    const jitter = Math.random() * 0.2;\n    return baseDelay * (1 + jitter);\n};\n// Updated retry logic: throws RateLimitError on 429, handles backoff for other errors\nconst retryWithBackoff = async function(fn, endpoint) {\n    let retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : MAX_RETRIES_PER_ENDPOINT, delay = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : INITIAL_RETRY_DELAY;\n    try {\n        return await fn();\n    } catch (error) {\n        var _error_message, _error_message1, _error_message2, _error_message3;\n        // Check specifically for rate limit error first\n        const isRateLimitError = ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"429\")) || error.status === 429 || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.toLowerCase().includes(\"rate limit\"));\n        if (isRateLimitError) {\n            console.warn(\"Rate limit detected on \".concat(endpoint, \". Switching endpoint.\"));\n            throw new RateLimitError(\"Rate limit hit on \".concat(endpoint)); // Throw specific error\n        }\n        // Better handling for null reference errors\n        if (((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"Cannot read properties of null\")) || ((_error_message3 = error.message) === null || _error_message3 === void 0 ? void 0 : _error_message3.includes(\"Cannot read property\"))) {\n            console.warn(\"Null reference error detected in SDK call. Endpoint: \".concat(endpoint, \", Error: \").concat(error.message));\n        // Either try again with backoff or throw a specific error to handle it differently\n        }\n        // Handle other errors with backoff\n        if (retries === 0) {\n            console.error(\"Max retries reached for non-rate-limit error on \".concat(endpoint, \". Error:\"), error);\n            throw error; // Throw original error after max retries\n        }\n        const nextDelay = Math.min(delay * 2, MAX_RETRY_DELAY);\n        const jitteredDelay = getJitter(nextDelay);\n        console.log(\"Retrying on \".concat(endpoint, \" in \").concat(jitteredDelay / 1000, \"s (attempt \").concat(MAX_RETRIES_PER_ENDPOINT - retries + 1, \"/\").concat(MAX_RETRIES_PER_ENDPOINT, \"). Error: \").concat(error.message));\n        await sleep(jitteredDelay);\n        return retryWithBackoff(fn, endpoint, retries - 1, nextDelay);\n    }\n};\n// createConnection now accepts the endpoint URL\nconst createConnection = async (rpcEndpoint)=>{\n    console.log(\"Attempting to connect to RPC: \".concat(rpcEndpoint));\n    const connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_3__.Connection(rpcEndpoint, \"confirmed\");\n    await connection.getEpochInfo(); // Test connection\n    console.log(\"Successfully connected to RPC: \".concat(rpcEndpoint));\n    return connection;\n};\n// Add this debugging helper before the DriftClientProvider component\nconst safelyExecuteSdkMethod = async (methodName, method, fallbackValue)=>{\n    try {\n        console.debug(\"Executing SDK method: \".concat(methodName));\n        const result = await method();\n        console.debug(\"Successfully executed SDK method: \".concat(methodName));\n        return result;\n    } catch (error) {\n        console.error(\"Error in SDK method \".concat(methodName, \":\"), error);\n        console.error(\"Stack trace for \".concat(methodName, \":\"), error.stack);\n        if (fallbackValue !== undefined) {\n            console.warn(\"Using fallback value for failed SDK method: \".concat(methodName));\n            return fallbackValue;\n        }\n        throw error;\n    }\n};\nfunction DriftClientProvider(param) {\n    let { children, onConnected } = param;\n    _s();\n    const [driftClient, setDriftClient] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [userAccounts, setUserAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isSubscribed, setIsSubscribed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [currentRpcIndex, setCurrentRpcIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [currentRpcEndpoint, setCurrentRpcEndpoint] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(RPC_ENDPOINTS[0] || null);\n    const { publicKey, signTransaction, signAllTransactions } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.useWallet)();\n    const isSubscribedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const isInitializedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const mountedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(true);\n    // Add a debug flag\n    const [sdkDebugMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        mountedRef.current = true;\n        isInitializedRef.current = false; // Reset initialization flag on wallet change\n        isSubscribedRef.current = false; // Reset subscription flag\n        setDriftClient(null); // Clear old client\n        setUserAccounts(null);\n        setError(null);\n        setIsConnected(false);\n        setIsSubscribed(false);\n        setIsLoading(true);\n        setCurrentRpcIndex(0); // Start from the first endpoint\n        setCurrentRpcEndpoint(RPC_ENDPOINTS[0] || null);\n        const initializeDriftClient = async ()=>{\n            if (!publicKey || !signTransaction || !signAllTransactions) {\n                if (mountedRef.current) {\n                    setIsLoading(false);\n                }\n                return;\n            }\n            let successfulInitialization = false;\n            let attemptIndex = 0;\n            const maxEndpointAttempts = RPC_ENDPOINTS.length;\n            while(!successfulInitialization && attemptIndex < maxEndpointAttempts && mountedRef.current){\n                const currentEndpoint = RPC_ENDPOINTS[attemptIndex];\n                setCurrentRpcEndpoint(currentEndpoint);\n                console.log(\"Attempting initialization with endpoint \".concat(attemptIndex + 1, \"/\").concat(maxEndpointAttempts, \": \").concat(currentEndpoint));\n                try {\n                    if (mountedRef.current) setError(null);\n                    // Try connecting with current endpoint\n                    const connection = await retryWithBackoff(()=>createConnection(currentEndpoint), currentEndpoint);\n                    // Initialize client with enhanced error logging\n                    if (sdkDebugMode) console.debug(\"Creating DriftClient instance...\");\n                    const clientConfig = {\n                        connection,\n                        wallet: {\n                            publicKey,\n                            signTransaction,\n                            signAllTransactions\n                        },\n                        env: \"devnet\",\n                        opts: {\n                            commitment: \"confirmed\",\n                            skipPreflight: true\n                        }\n                    };\n                    if (sdkDebugMode) console.debug(\"Client config:\", JSON.stringify(clientConfig, (key, value)=>key === \"connection\" ? \"[Connection Object]\" : key === \"publicKey\" ? value.toString() : key === \"signTransaction\" || key === \"signAllTransactions\" ? \"[Function]\" : value));\n                    const client = new _drift_labs_sdk__WEBPACK_IMPORTED_MODULE_2__.DriftClient(clientConfig);\n                    if (!mountedRef.current) return;\n                    // Additional validation\n                    if (!client) {\n                        console.error(\"DriftClient was not properly initialized\");\n                        throw new Error(\"Failed to initialize DriftClient\");\n                    }\n                    // Check if required methods exist\n                    if (typeof client.subscribe !== \"function\") {\n                        console.error(\"DriftClient.subscribe is not a function\");\n                        throw new Error(\"Malformed DriftClient instance\");\n                    }\n                    if (typeof client.getUserAccountsForAuthority !== \"function\") {\n                        console.error(\"DriftClient.getUserAccountsForAuthority is not a function\");\n                        throw new Error(\"Malformed DriftClient instance\");\n                    }\n                    setDriftClient(client);\n                    setIsConnected(true);\n                    isInitializedRef.current = true;\n                    // Try subscribing with more safety measures\n                    if (!isSubscribedRef.current) {\n                        await sleep(5000); // Increased delay to 5 seconds\n                        if (sdkDebugMode) console.debug(\"Attempting to subscribe to DriftClient events...\");\n                        await retryWithBackoff(async ()=>{\n                            if (!client) throw new Error(\"Client not available for subscribe\");\n                            // Wrap the SDK call in our safe executor\n                            await safelyExecuteSdkMethod(\"client.subscribe\", async ()=>{\n                                // Check internal state of client before subscribing\n                                if (!client.connection) {\n                                    throw new Error(\"Client connection is null before subscribe\");\n                                }\n                                // Safe subscribe with extra logging\n                                console.debug(\"[safelyExecuteSdkMethod] Calling client.subscribe()...\");\n                                try {\n                                    const subscribeResult = await client.subscribe();\n                                    console.debug(\"[safelyExecuteSdkMethod] client.subscribe() returned successfully.\");\n                                    if (!mountedRef.current) return false; // Check mount status after async call\n                                    // Check the result if necessary (depends on SDK)\n                                    if (!subscribeResult) {\n                                        console.warn(\"client.subscribe() returned falsy value\");\n                                    // Consider throwing an error if subscribeResult is critical\n                                    }\n                                    console.log(\"Successfully subscribed on endpoint: \".concat(currentEndpoint));\n                                    setIsSubscribed(true);\n                                    isSubscribedRef.current = true;\n                                    if (onConnected) {\n                                        console.log(\"Calling onConnected callback...\");\n                                        onConnected();\n                                    }\n                                    return true; // Indicate success for retryWithBackoff\n                                } catch (subscribeError) {\n                                    console.error(\"Error during client.subscribe() on \".concat(currentEndpoint, \":\"), subscribeError);\n                                    setIsSubscribed(false);\n                                    isSubscribedRef.current = false;\n                                    // Re-throw to allow retryWithBackoff to handle it\n                                    throw subscribeError;\n                                }\n                            });\n                        }, currentEndpoint);\n                        if (!mountedRef.current) return;\n                        setIsSubscribed(true);\n                        isSubscribedRef.current = true;\n                        console.log(\"Successfully subscribed via \".concat(currentEndpoint));\n                    }\n                    // Try fetching accounts with more safety measures\n                    if (!userAccounts) {\n                        try {\n                            // Longer delay before fetching accounts\n                            await sleep(2000);\n                            if (sdkDebugMode) console.debug(\"Attempting to fetch user accounts...\");\n                            await retryWithBackoff(async ()=>{\n                                if (!client) throw new Error(\"Client not available for getUserAccounts\");\n                                if (!publicKey) throw new Error(\"Public key not available for getUserAccounts\");\n                                // Wrap the SDK call in our safe executor with a fallback empty array\n                                const accounts = await safelyExecuteSdkMethod(\"client.getUserAccountsForAuthority\", async ()=>{\n                                    // Check connection and other required objects\n                                    if (!client.connection) {\n                                        throw new Error(\"Client connection is null before getUserAccounts\");\n                                    }\n                                    // Safe get accounts\n                                    return await client.getUserAccountsForAuthority(publicKey);\n                                }, [] // Fallback to empty array\n                                );\n                                if (mountedRef.current) setUserAccounts(accounts || []);\n                            }, currentEndpoint);\n                        } catch (fetchErr) {\n                            console.warn(\"Failed to fetch user accounts via \".concat(currentEndpoint, \" (non-fatal):\"), fetchErr);\n                            if (mountedRef.current) setUserAccounts([]);\n                        }\n                    }\n                    // Success!\n                    successfulInitialization = true;\n                    if (mountedRef.current) setIsLoading(false);\n                    console.log(\"Drift client fully initialized and subscribed via \".concat(currentEndpoint));\n                } catch (err) {\n                    var _err_message;\n                    if (!mountedRef.current) return;\n                    console.error(\"Error during initialization/subscription: \".concat(err.message || \"Unknown error\"), err);\n                    // Log additional diagnostic info about the failure\n                    if (sdkDebugMode) {\n                        console.debug(\"Error details:\", {\n                            endpoint: currentEndpoint,\n                            message: err.message,\n                            name: err.name,\n                            stack: err.stack,\n                            isRateLimitError: err instanceof RateLimitError\n                        });\n                    }\n                    const isNullReferenceError = (_err_message = err.message) === null || _err_message === void 0 ? void 0 : _err_message.includes(\"Cannot read properties of null\");\n                    if (err instanceof RateLimitError || isNullReferenceError) {\n                        // Treat null reference errors during init/sub like rate limits - try next endpoint immediately\n                        const errorType = err instanceof RateLimitError ? \"Rate limit\" : \"Null reference\";\n                        console.warn(\"\".concat(errorType, \" error hit on \").concat(currentEndpoint, \", trying next endpoint...\"));\n                        await sleep(ENDPOINT_SWITCH_DELAY);\n                    } else {\n                        console.error(\"Failed to initialize/subscribe via \".concat(currentEndpoint, \" after retries:\"), err);\n                        await sleep(ENDPOINT_SWITCH_DELAY);\n                    }\n                }\n                attemptIndex++;\n            }\n            // After loop: check if initialization failed after trying all endpoints\n            if (!successfulInitialization && mountedRef.current) {\n                console.error(\"Failed to initialize Drift client after trying all RPC endpoints.\");\n                setError(\"Failed to connect to Drift after trying all available RPC endpoints.\");\n                setIsLoading(false);\n                react_hot_toast__WEBPACK_IMPORTED_MODULE_4__.toast.error(\"Could not connect to Drift. Please try again later or check network.\");\n            }\n        };\n        initializeDriftClient();\n        // Cleanup function\n        return ()=>{\n            mountedRef.current = false;\n            console.log(\"DriftClientProvider cleaning up...\");\n            const currentDriftClient = driftClient; // Capture current value for cleanup\n            if (currentDriftClient && isSubscribedRef.current) {\n                currentDriftClient.unsubscribe().catch((err)=>{\n                    console.error(\"Error unsubscribing from Drift client:\", err);\n                });\n            }\n            isSubscribedRef.current = false;\n            isInitializedRef.current = false;\n        };\n    // REMOVE driftClient from dependency array\n    }, [\n        publicKey,\n        signTransaction,\n        signAllTransactions,\n        onConnected,\n        sdkDebugMode\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DriftClientContext.Provider, {\n        value: {\n            driftClient,\n            userAccounts,\n            error,\n            isLoading,\n            isConnected,\n            isSubscribed,\n            currentRpcEndpoint\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/samisha/Projects/drift-trading-ui/components/DriftClientProvider.tsx\",\n        lineNumber: 387,\n        columnNumber: 5\n    }, this);\n}\n_s(DriftClientProvider, \"KMJ7NQXOF8HDs/IDHhKKOnSgpq8=\", false, function() {\n    return [\n        _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.useWallet\n    ];\n});\n_c1 = DriftClientProvider;\nconst useDriftClient = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(DriftClientContext);\n    if (context === undefined) {\n        throw new Error(\"useDriftClient must be used within a DriftClientProvider\");\n    }\n    return context;\n};\n_s1(useDriftClient, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c, _c1;\n$RefreshReg$(_c, \"RPC_ENDPOINTS\");\n$RefreshReg$(_c1, \"DriftClientProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvRHJpZnRDbGllbnRQcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBRTBGO0FBQy9CO0FBQ0Y7QUFDVztBQUM1QjtBQUV4QyxpQ0FBaUM7QUFDakMsTUFBTVMsdUJBQXVCQztJQUMzQkMsWUFBWUMsT0FBZSxDQUFFO1FBQzNCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFZQSxNQUFNQyxtQ0FBcUJkLG9EQUFhQSxDQUF5QjtJQUMvRGUsYUFBYTtJQUNiQyxjQUFjO0lBQ2RDLE9BQU87SUFDUEMsV0FBVztJQUNYQyxhQUFhO0lBQ2JDLGNBQWM7SUFDZEMsb0JBQW9CO0FBQ3RCO0FBRUEsb0VBQW9FO0FBQ3BFLE1BQU1DLGdCQUFnQjtJQUNwQjtJQUNBQyw2RUFBc0MsSUFBSSxDQUE2RTtDQUV4SCxDQUFDRyxNQUFNLENBQUNDLFVBQVUsaURBQWlEOztBQUVwRSxNQUFNQywyQkFBMkIsR0FBRyxxREFBcUQ7QUFDekYsTUFBTUMsc0JBQXNCLE1BQU0sK0JBQStCO0FBQ2pFLE1BQU1DLGtCQUFrQixPQUFPLGdDQUFnQztBQUMvRCxNQUFNQyx3QkFBd0IsTUFBTSwwQ0FBMEM7QUFFOUUsTUFBTUMsUUFBUSxDQUFDQyxLQUFlLElBQUlDLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVNGO0FBRXpFLE1BQU1JLFlBQVksQ0FBQ0M7SUFDakIsTUFBTUMsU0FBU0MsS0FBS0MsTUFBTSxLQUFLO0lBQy9CLE9BQU9ILFlBQWEsS0FBSUMsTUFBSztBQUMvQjtBQUVBLHNGQUFzRjtBQUN0RixNQUFNRyxtQkFBbUIsZUFDdkJDLElBQ0FDO1FBQ0FDLDJFQUFVakIsMEJBQ1ZrQix5RUFBUWpCO0lBRVIsSUFBSTtRQUNGLE9BQU8sTUFBTWM7SUFDZixFQUFFLE9BQU8xQixPQUFZO1lBRU1BLGdCQUVGQSxpQkFRbkJBLGlCQUNBQTtRQVpKLGdEQUFnRDtR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eUQsU0FBUztnQkFDVEcsYUFBYTtnQkFDYnJFLGtEQUFLQSxDQUFDUyxLQUFLLENBQUM7WUFDZDtRQUNGO1FBRUF3RTtRQUVBLG1CQUFtQjtRQUNuQixPQUFPO1lBQ0xILFdBQVdFLE9BQU8sR0FBRztZQUNyQnJDLFFBQVFLLEdBQUcsQ0FBQztZQUNaLE1BQU0yRCxxQkFBcUJwRyxhQUFhLG9DQUFvQztZQUM1RSxJQUFJb0csc0JBQXNCL0IsZ0JBQWdCSSxPQUFPLEVBQUU7Z0JBQ2pEMkIsbUJBQW1CQyxXQUFXLEdBQUdDLEtBQUssQ0FBQ0wsQ0FBQUE7b0JBQ3JDN0QsUUFBUWxDLEtBQUssQ0FBQywwQ0FBMEMrRjtnQkFDMUQ7WUFDRjtZQUNBNUIsZ0JBQWdCSSxPQUFPLEdBQUc7WUFDMUJILGlCQUFpQkcsT0FBTyxHQUFHO1FBQzdCO0lBQ0YsMkNBQTJDO0lBQzNDLEdBQUc7UUFBQ1A7UUFBV0M7UUFBaUJDO1FBQXFCWjtRQUFhZ0I7S0FBYTtJQUUvRSxxQkFDRSw4REFBQ3pFLG1CQUFtQndHLFFBQVE7UUFBQ2YsT0FBTztZQUNsQ3hGO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1FBQ0Y7a0JBQ0dpRDs7Ozs7O0FBR1A7R0F6UWdCRDs7UUFTOEMvRCxtRUFBU0E7OztNQVR2RCtEO0FBMlFULE1BQU1rRCxpQkFBaUI7O0lBQzVCLE1BQU1DLFVBQVV2SCxpREFBVUEsQ0FBQ2E7SUFDM0IsSUFBSTBHLFlBQVlwRCxXQUFXO1FBQ3pCLE1BQU0sSUFBSTFELE1BQU07SUFDbEI7SUFDQSxPQUFPOEc7QUFDVCxFQUFFO0lBTldEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvRHJpZnRDbGllbnRQcm92aWRlci50c3g/YTBkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgUmVhY3ROb2RlLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IERyaWZ0Q2xpZW50LCBVc2VyQWNjb3VudCB9IGZyb20gXCJAZHJpZnQtbGFicy9zZGtcIjtcbmltcG9ydCB7IHVzZVdhbGxldCB9IGZyb20gXCJAc29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0XCI7XG5pbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXksIENvbW1pdG1lbnQgfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gXCJyZWFjdC1ob3QtdG9hc3RcIjtcblxuLy8gQ3VzdG9tIGVycm9yIGZvciByYXRlIGxpbWl0aW5nXG5jbGFzcyBSYXRlTGltaXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJSYXRlTGltaXRFcnJvclwiO1xuICB9XG59XG5cbmludGVyZmFjZSBEcmlmdENsaWVudENvbnRleHRUeXBlIHtcbiAgZHJpZnRDbGllbnQ6IERyaWZ0Q2xpZW50IHwgbnVsbDtcbiAgdXNlckFjY291bnRzOiBVc2VyQWNjb3VudFtdIHwgbnVsbDtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgaXNDb25uZWN0ZWQ6IGJvb2xlYW47XG4gIGlzU3Vic2NyaWJlZDogYm9vbGVhbjtcbiAgY3VycmVudFJwY0VuZHBvaW50OiBzdHJpbmcgfCBudWxsOyAvLyBFeHBvc2UgY3VycmVudCBSUEMgZW5kcG9pbnRcbn1cblxuY29uc3QgRHJpZnRDbGllbnRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxEcmlmdENsaWVudENvbnRleHRUeXBlPih7XG4gIGRyaWZ0Q2xpZW50OiBudWxsLFxuICB1c2VyQWNjb3VudHM6IG51bGwsXG4gIGVycm9yOiBudWxsLFxuICBpc0xvYWRpbmc6IHRydWUsXG4gIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgaXNTdWJzY3JpYmVkOiBmYWxzZSxcbiAgY3VycmVudFJwY0VuZHBvaW50OiBudWxsLFxufSk7XG5cbi8vIERlZmluZSBtdWx0aXBsZSBSUEMgZW5kcG9pbnRzIC0gUHJpb3JpdGl6ZSBwdWJsaWMgU29sYW5hIGVuZHBvaW50XG5jb25zdCBSUENfRU5EUE9JTlRTID0gW1xuICBcImh0dHBzOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tXCIsIC8vIFB1YmxpYyBmYWxsYmFjayBmaXJzdFxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19IRUxJVVNfUlBDX1VSTCB8fCBcImh0dHBzOi8vZGV2bmV0LmhlbGl1cy1ycGMuY29tLz9hcGkta2V5PTc2NTQ3MjcwLTIyNmQtNDQ2ZC04MjkzLWMxYjNmOGU4ZWExYlwiLFxuICAvLyBBZGQgbW9yZSBiYWNrdXAgZW5kcG9pbnRzIGhlcmUgaWYgYXZhaWxhYmxlXG5dLmZpbHRlcihCb29sZWFuKTsgLy8gRmlsdGVyIG91dCBhbnkgcG90ZW50aWFsIHVuZGVmaW5lZC9udWxsIHZhbHVlc1xuXG5jb25zdCBNQVhfUkVUUklFU19QRVJfRU5EUE9JTlQgPSA1OyAvLyBNYXggcmV0cmllcyBmb3Igbm9uLXJhdGUtbGltaXQgZXJyb3JzIHBlciBlbmRwb2ludFxuY29uc3QgSU5JVElBTF9SRVRSWV9ERUxBWSA9IDUwMDA7IC8vIDUgc2Vjb25kcyBmb3IgcmVndWxhciBlcnJvcnNcbmNvbnN0IE1BWF9SRVRSWV9ERUxBWSA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzIGZvciByZWd1bGFyIGVycm9yc1xuY29uc3QgRU5EUE9JTlRfU1dJVENIX0RFTEFZID0gMTAwMDsgLy8gU2hvcnQgZGVsYXkgYmVmb3JlIHRyeWluZyBuZXh0IGVuZHBvaW50XG5cbmNvbnN0IHNsZWVwID0gKG1zOiBudW1iZXIpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG5jb25zdCBnZXRKaXR0ZXIgPSAoYmFzZURlbGF5OiBudW1iZXIpID0+IHtcbiAgY29uc3Qgaml0dGVyID0gTWF0aC5yYW5kb20oKSAqIDAuMjsgXG4gIHJldHVybiBiYXNlRGVsYXkgKiAoMSArIGppdHRlcik7XG59O1xuXG4vLyBVcGRhdGVkIHJldHJ5IGxvZ2ljOiB0aHJvd3MgUmF0ZUxpbWl0RXJyb3Igb24gNDI5LCBoYW5kbGVzIGJhY2tvZmYgZm9yIG90aGVyIGVycm9yc1xuY29uc3QgcmV0cnlXaXRoQmFja29mZiA9IGFzeW5jIDxULD4oXG4gIGZuOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBlbmRwb2ludDogc3RyaW5nLCAvLyBQYXNzIGVuZHBvaW50IGZvciBsb2dnaW5nXG4gIHJldHJpZXMgPSBNQVhfUkVUUklFU19QRVJfRU5EUE9JTlQsXG4gIGRlbGF5ID0gSU5JVElBTF9SRVRSWV9ERUxBWVxuKTogUHJvbWlzZTxUPiA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyBDaGVjayBzcGVjaWZpY2FsbHkgZm9yIHJhdGUgbGltaXQgZXJyb3IgZmlyc3RcbiAgICBjb25zdCBpc1JhdGVMaW1pdEVycm9yID0gZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJzQyOScpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhdHVzID09PSA0MjkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdyYXRlIGxpbWl0Jyk7XG4gICAgXG4gICAgaWYgKGlzUmF0ZUxpbWl0RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgUmF0ZSBsaW1pdCBkZXRlY3RlZCBvbiAke2VuZHBvaW50fS4gU3dpdGNoaW5nIGVuZHBvaW50LmApO1xuICAgICAgdGhyb3cgbmV3IFJhdGVMaW1pdEVycm9yKGBSYXRlIGxpbWl0IGhpdCBvbiAke2VuZHBvaW50fWApOyAvLyBUaHJvdyBzcGVjaWZpYyBlcnJvclxuICAgIH1cblxuICAgIC8vIEJldHRlciBoYW5kbGluZyBmb3IgbnVsbCByZWZlcmVuY2UgZXJyb3JzXG4gICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdDYW5ub3QgcmVhZCBwcm9wZXJ0aWVzIG9mIG51bGwnKSB8fCBcbiAgICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ0Nhbm5vdCByZWFkIHByb3BlcnR5JykpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTnVsbCByZWZlcmVuY2UgZXJyb3IgZGV0ZWN0ZWQgaW4gU0RLIGNhbGwuIEVuZHBvaW50OiAke2VuZHBvaW50fSwgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIC8vIEVpdGhlciB0cnkgYWdhaW4gd2l0aCBiYWNrb2ZmIG9yIHRocm93IGEgc3BlY2lmaWMgZXJyb3IgdG8gaGFuZGxlIGl0IGRpZmZlcmVudGx5XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG90aGVyIGVycm9ycyB3aXRoIGJhY2tvZmZcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcihgTWF4IHJldHJpZXMgcmVhY2hlZCBmb3Igbm9uLXJhdGUtbGltaXQgZXJyb3Igb24gJHtlbmRwb2ludH0uIEVycm9yOmAsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yOyAvLyBUaHJvdyBvcmlnaW5hbCBlcnJvciBhZnRlciBtYXggcmV0cmllc1xuICAgIH1cblxuICAgIGNvbnN0IG5leHREZWxheSA9IE1hdGgubWluKGRlbGF5ICogMiwgTUFYX1JFVFJZX0RFTEFZKTtcbiAgICBjb25zdCBqaXR0ZXJlZERlbGF5ID0gZ2V0Sml0dGVyKG5leHREZWxheSk7XG4gICAgY29uc29sZS5sb2coYFJldHJ5aW5nIG9uICR7ZW5kcG9pbnR9IGluICR7aml0dGVyZWREZWxheS8xMDAwfXMgKGF0dGVtcHQgJHtNQVhfUkVUUklFU19QRVJfRU5EUE9JTlQgLSByZXRyaWVzICsgMX0vJHtNQVhfUkVUUklFU19QRVJfRU5EUE9JTlR9KS4gRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICBhd2FpdCBzbGVlcChqaXR0ZXJlZERlbGF5KTtcbiAgICByZXR1cm4gcmV0cnlXaXRoQmFja29mZihmbiwgZW5kcG9pbnQsIHJldHJpZXMgLSAxLCBuZXh0RGVsYXkpO1xuICB9XG59O1xuXG4vLyBjcmVhdGVDb25uZWN0aW9uIG5vdyBhY2NlcHRzIHRoZSBlbmRwb2ludCBVUkxcbmNvbnN0IGNyZWF0ZUNvbm5lY3Rpb24gPSBhc3luYyAocnBjRW5kcG9pbnQ6IHN0cmluZyk6IFByb21pc2U8Q29ubmVjdGlvbj4gPT4ge1xuICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIFJQQzogJHtycGNFbmRwb2ludH1gKTtcbiAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKHJwY0VuZHBvaW50LCAnY29uZmlybWVkJyk7XG4gIGF3YWl0IGNvbm5lY3Rpb24uZ2V0RXBvY2hJbmZvKCk7IC8vIFRlc3QgY29ubmVjdGlvblxuICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCB0byBSUEM6ICR7cnBjRW5kcG9pbnR9YCk7XG4gIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuLy8gQWRkIHRoaXMgZGVidWdnaW5nIGhlbHBlciBiZWZvcmUgdGhlIERyaWZ0Q2xpZW50UHJvdmlkZXIgY29tcG9uZW50XG5jb25zdCBzYWZlbHlFeGVjdXRlU2RrTWV0aG9kID0gYXN5bmMgPFQsPihcbiAgbWV0aG9kTmFtZTogc3RyaW5nLFxuICBtZXRob2Q6ICgpID0+IFByb21pc2U8VD4sXG4gIGZhbGxiYWNrVmFsdWU/OiBUXG4pOiBQcm9taXNlPFQ+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmRlYnVnKGBFeGVjdXRpbmcgU0RLIG1ldGhvZDogJHttZXRob2ROYW1lfWApO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1ldGhvZCgpO1xuICAgIGNvbnNvbGUuZGVidWcoYFN1Y2Nlc3NmdWxseSBleGVjdXRlZCBTREsgbWV0aG9kOiAke21ldGhvZE5hbWV9YCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIFNESyBtZXRob2QgJHttZXRob2ROYW1lfTpgLCBlcnJvcik7XG4gICAgY29uc29sZS5lcnJvcihgU3RhY2sgdHJhY2UgZm9yICR7bWV0aG9kTmFtZX06YCwgZXJyb3Iuc3RhY2spO1xuICAgIFxuICAgIGlmIChmYWxsYmFja1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVXNpbmcgZmFsbGJhY2sgdmFsdWUgZm9yIGZhaWxlZCBTREsgbWV0aG9kOiAke21ldGhvZE5hbWV9YCk7XG4gICAgICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmludGVyZmFjZSBEcmlmdENsaWVudFByb3ZpZGVyUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3ROb2RlO1xuICBvbkNvbm5lY3RlZD86ICgpID0+IHZvaWQ7IC8vIEFkZCBvbkNvbm5lY3RlZCBwcm9wXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEcmlmdENsaWVudFByb3ZpZGVyKHsgY2hpbGRyZW4sIG9uQ29ubmVjdGVkIH06IERyaWZ0Q2xpZW50UHJvdmlkZXJQcm9wcykge1xuICBjb25zdCBbZHJpZnRDbGllbnQsIHNldERyaWZ0Q2xpZW50XSA9IHVzZVN0YXRlPERyaWZ0Q2xpZW50IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFt1c2VyQWNjb3VudHMsIHNldFVzZXJBY2NvdW50c10gPSB1c2VTdGF0ZTxVc2VyQWNjb3VudFtdIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtpc0Nvbm5lY3RlZCwgc2V0SXNDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNTdWJzY3JpYmVkLCBzZXRJc1N1YnNjcmliZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtjdXJyZW50UnBjSW5kZXgsIHNldEN1cnJlbnRScGNJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2N1cnJlbnRScGNFbmRwb2ludCwgc2V0Q3VycmVudFJwY0VuZHBvaW50XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KFJQQ19FTkRQT0lOVFNbMF0gfHwgbnVsbCk7XG4gIGNvbnN0IHsgcHVibGljS2V5LCBzaWduVHJhbnNhY3Rpb24sIHNpZ25BbGxUcmFuc2FjdGlvbnMgfSA9IHVzZVdhbGxldCgpO1xuICBcbiAgY29uc3QgaXNTdWJzY3JpYmVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaXNJbml0aWFsaXplZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IG1vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSk7XG5cbiAgLy8gQWRkIGEgZGVidWcgZmxhZ1xuICBjb25zdCBbc2RrRGVidWdNb2RlXSA9IHVzZVN0YXRlKHRydWUpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBpc0luaXRpYWxpemVkUmVmLmN1cnJlbnQgPSBmYWxzZTsgLy8gUmVzZXQgaW5pdGlhbGl6YXRpb24gZmxhZyBvbiB3YWxsZXQgY2hhbmdlXG4gICAgaXNTdWJzY3JpYmVkUmVmLmN1cnJlbnQgPSBmYWxzZTsgLy8gUmVzZXQgc3Vic2NyaXB0aW9uIGZsYWdcbiAgICBzZXREcmlmdENsaWVudChudWxsKTsgLy8gQ2xlYXIgb2xkIGNsaWVudFxuICAgIHNldFVzZXJBY2NvdW50cyhudWxsKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XG4gICAgc2V0SXNTdWJzY3JpYmVkKGZhbHNlKTtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0Q3VycmVudFJwY0luZGV4KDApOyAvLyBTdGFydCBmcm9tIHRoZSBmaXJzdCBlbmRwb2ludFxuICAgIHNldEN1cnJlbnRScGNFbmRwb2ludChSUENfRU5EUE9JTlRTWzBdIHx8IG51bGwpO1xuXG4gICAgY29uc3QgaW5pdGlhbGl6ZURyaWZ0Q2xpZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFwdWJsaWNLZXkgfHwgIXNpZ25UcmFuc2FjdGlvbiB8fCAhc2lnbkFsbFRyYW5zYWN0aW9ucykge1xuICAgICAgICBpZiAobW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTsgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgc3VjY2Vzc2Z1bEluaXRpYWxpemF0aW9uID0gZmFsc2U7XG4gICAgICBsZXQgYXR0ZW1wdEluZGV4ID0gMDtcbiAgICAgIGNvbnN0IG1heEVuZHBvaW50QXR0ZW1wdHMgPSBSUENfRU5EUE9JTlRTLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCFzdWNjZXNzZnVsSW5pdGlhbGl6YXRpb24gJiYgYXR0ZW1wdEluZGV4IDwgbWF4RW5kcG9pbnRBdHRlbXB0cyAmJiBtb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEVuZHBvaW50ID0gUlBDX0VORFBPSU5UU1thdHRlbXB0SW5kZXhdO1xuICAgICAgICBzZXRDdXJyZW50UnBjRW5kcG9pbnQoY3VycmVudEVuZHBvaW50KTtcbiAgICAgICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgaW5pdGlhbGl6YXRpb24gd2l0aCBlbmRwb2ludCAke2F0dGVtcHRJbmRleCArIDF9LyR7bWF4RW5kcG9pbnRBdHRlbXB0c306ICR7Y3VycmVudEVuZHBvaW50fWApO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG1vdW50ZWRSZWYuY3VycmVudCkgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgICAgICAvLyBUcnkgY29ubmVjdGluZyB3aXRoIGN1cnJlbnQgZW5kcG9pbnRcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgcmV0cnlXaXRoQmFja29mZigoKSA9PiBjcmVhdGVDb25uZWN0aW9uKGN1cnJlbnRFbmRwb2ludCksIGN1cnJlbnRFbmRwb2ludCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSBjbGllbnQgd2l0aCBlbmhhbmNlZCBlcnJvciBsb2dnaW5nXG4gICAgICAgICAgaWYgKHNka0RlYnVnTW9kZSkgY29uc29sZS5kZWJ1ZyhcIkNyZWF0aW5nIERyaWZ0Q2xpZW50IGluc3RhbmNlLi4uXCIpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGNsaWVudENvbmZpZyA9IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24sXG4gICAgICAgICAgICB3YWxsZXQ6IHsgcHVibGljS2V5LCBzaWduVHJhbnNhY3Rpb24sIHNpZ25BbGxUcmFuc2FjdGlvbnMgfSxcbiAgICAgICAgICAgIGVudjogXCJkZXZuZXRcIiBhcyBjb25zdCxcbiAgICAgICAgICAgIG9wdHM6IHsgXG4gICAgICAgICAgICAgIGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnIGFzIENvbW1pdG1lbnQsIFxuICAgICAgICAgICAgICBza2lwUHJlZmxpZ2h0OiB0cnVlIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHNka0RlYnVnTW9kZSkgY29uc29sZS5kZWJ1ZyhcIkNsaWVudCBjb25maWc6XCIsIEpTT04uc3RyaW5naWZ5KGNsaWVudENvbmZpZywgKGtleSwgdmFsdWUpID0+IFxuICAgICAgICAgICAga2V5ID09PSAnY29ubmVjdGlvbicgPyAnW0Nvbm5lY3Rpb24gT2JqZWN0XScgOiBcbiAgICAgICAgICAgIGtleSA9PT0gJ3B1YmxpY0tleScgPyB2YWx1ZS50b1N0cmluZygpIDogXG4gICAgICAgICAgICBrZXkgPT09ICdzaWduVHJhbnNhY3Rpb24nIHx8IGtleSA9PT0gJ3NpZ25BbGxUcmFuc2FjdGlvbnMnID8gJ1tGdW5jdGlvbl0nIDogXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICkpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBEcmlmdENsaWVudChjbGllbnRDb25maWcpO1xuXG4gICAgICAgICAgaWYgKCFtb3VudGVkUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGRpdGlvbmFsIHZhbGlkYXRpb25cbiAgICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyaWZ0Q2xpZW50IHdhcyBub3QgcHJvcGVybHkgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBEcmlmdENsaWVudFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgcmVxdWlyZWQgbWV0aG9kcyBleGlzdFxuICAgICAgICAgIGlmICh0eXBlb2YgY2xpZW50LnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyaWZ0Q2xpZW50LnN1YnNjcmliZSBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBEcmlmdENsaWVudCBpbnN0YW5jZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHR5cGVvZiBjbGllbnQuZ2V0VXNlckFjY291bnRzRm9yQXV0aG9yaXR5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRHJpZnRDbGllbnQuZ2V0VXNlckFjY291bnRzRm9yQXV0aG9yaXR5IGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIERyaWZ0Q2xpZW50IGluc3RhbmNlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBzZXREcmlmdENsaWVudChjbGllbnQpO1xuICAgICAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpO1xuICAgICAgICAgIGlzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBUcnkgc3Vic2NyaWJpbmcgd2l0aCBtb3JlIHNhZmV0eSBtZWFzdXJlc1xuICAgICAgICAgIGlmICghaXNTdWJzY3JpYmVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKDUwMDApOyAvLyBJbmNyZWFzZWQgZGVsYXkgdG8gNSBzZWNvbmRzXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzZGtEZWJ1Z01vZGUpIGNvbnNvbGUuZGVidWcoXCJBdHRlbXB0aW5nIHRvIHN1YnNjcmliZSB0byBEcmlmdENsaWVudCBldmVudHMuLi5cIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGF3YWl0IHJldHJ5V2l0aEJhY2tvZmYoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWNsaWVudCkgdGhyb3cgbmV3IEVycm9yKFwiQ2xpZW50IG5vdCBhdmFpbGFibGUgZm9yIHN1YnNjcmliZVwiKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFdyYXAgdGhlIFNESyBjYWxsIGluIG91ciBzYWZlIGV4ZWN1dG9yXG4gICAgICAgICAgICAgIGF3YWl0IHNhZmVseUV4ZWN1dGVTZGtNZXRob2QoJ2NsaWVudC5zdWJzY3JpYmUnLCBcbiAgICAgICAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAvLyBDaGVjayBpbnRlcm5hbCBzdGF0ZSBvZiBjbGllbnQgYmVmb3JlIHN1YnNjcmliaW5nXG4gICAgICAgICAgICAgICAgICBpZiAoIWNsaWVudC5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsaWVudCBjb25uZWN0aW9uIGlzIG51bGwgYmVmb3JlIHN1YnNjcmliZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gU2FmZSBzdWJzY3JpYmUgd2l0aCBleHRyYSBsb2dnaW5nXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiW3NhZmVseUV4ZWN1dGVTZGtNZXRob2RdIENhbGxpbmcgY2xpZW50LnN1YnNjcmliZSgpLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlUmVzdWx0ID0gYXdhaXQgY2xpZW50LnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiW3NhZmVseUV4ZWN1dGVTZGtNZXRob2RdIGNsaWVudC5zdWJzY3JpYmUoKSByZXR1cm5lZCBzdWNjZXNzZnVsbHkuXCIpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3VudGVkUmVmLmN1cnJlbnQpIHJldHVybiBmYWxzZTsgLy8gQ2hlY2sgbW91bnQgc3RhdHVzIGFmdGVyIGFzeW5jIGNhbGxcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmVzdWx0IGlmIG5lY2Vzc2FyeSAoZGVwZW5kcyBvbiBTREspXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlUmVzdWx0KSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiY2xpZW50LnN1YnNjcmliZSgpIHJldHVybmVkIGZhbHN5IHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhyb3dpbmcgYW4gZXJyb3IgaWYgc3Vic2NyaWJlUmVzdWx0IGlzIGNyaXRpY2FsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgc3Vic2NyaWJlZCBvbiBlbmRwb2ludDogJHtjdXJyZW50RW5kcG9pbnR9YCk7XG4gICAgICAgICAgICAgICAgICAgIHNldElzU3Vic2NyaWJlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaXNTdWJzY3JpYmVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25Db25uZWN0ZWQpIHsgLy8gQ2FsbCBvbkNvbm5lY3RlZCBjYWxsYmFjayBpZiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2FsbGluZyBvbkNvbm5lY3RlZCBjYWxsYmFjay4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBvbkNvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBJbmRpY2F0ZSBzdWNjZXNzIGZvciByZXRyeVdpdGhCYWNrb2ZmXG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChzdWJzY3JpYmVFcnJvcjogYW55KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmluZyBjbGllbnQuc3Vic2NyaWJlKCkgb24gJHtjdXJyZW50RW5kcG9pbnR9OmAsIHN1YnNjcmliZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SXNTdWJzY3JpYmVkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaXNTdWJzY3JpYmVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdG8gYWxsb3cgcmV0cnlXaXRoQmFja29mZiB0byBoYW5kbGUgaXRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3Vic2NyaWJlRXJyb3I7IFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sIGN1cnJlbnRFbmRwb2ludCk7XG4gICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIW1vdW50ZWRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICAgICAgc2V0SXNTdWJzY3JpYmVkKHRydWUpO1xuICAgICAgICAgICAgaXNTdWJzY3JpYmVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBzdWJzY3JpYmVkIHZpYSAke2N1cnJlbnRFbmRwb2ludH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUcnkgZmV0Y2hpbmcgYWNjb3VudHMgd2l0aCBtb3JlIHNhZmV0eSBtZWFzdXJlc1xuICAgICAgICAgIGlmICghdXNlckFjY291bnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBMb25nZXIgZGVsYXkgYmVmb3JlIGZldGNoaW5nIGFjY291bnRzXG4gICAgICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMDApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHNka0RlYnVnTW9kZSkgY29uc29sZS5kZWJ1ZyhcIkF0dGVtcHRpbmcgdG8gZmV0Y2ggdXNlciBhY2NvdW50cy4uLlwiKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGF3YWl0IHJldHJ5V2l0aEJhY2tvZmYoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY2xpZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnQgbm90IGF2YWlsYWJsZSBmb3IgZ2V0VXNlckFjY291bnRzXCIpO1xuICAgICAgICAgICAgICAgIGlmICghcHVibGljS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJQdWJsaWMga2V5IG5vdCBhdmFpbGFibGUgZm9yIGdldFVzZXJBY2NvdW50c1wiKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBXcmFwIHRoZSBTREsgY2FsbCBpbiBvdXIgc2FmZSBleGVjdXRvciB3aXRoIGEgZmFsbGJhY2sgZW1wdHkgYXJyYXlcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHNhZmVseUV4ZWN1dGVTZGtNZXRob2QoJ2NsaWVudC5nZXRVc2VyQWNjb3VudHNGb3JBdXRob3JpdHknLFxuICAgICAgICAgICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBjb25uZWN0aW9uIGFuZCBvdGhlciByZXF1aXJlZCBvYmplY3RzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xpZW50LmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnQgY29ubmVjdGlvbiBpcyBudWxsIGJlZm9yZSBnZXRVc2VyQWNjb3VudHNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmUgZ2V0IGFjY291bnRzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBjbGllbnQuZ2V0VXNlckFjY291bnRzRm9yQXV0aG9yaXR5KHB1YmxpY0tleSk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW10gLy8gRmFsbGJhY2sgdG8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChtb3VudGVkUmVmLmN1cnJlbnQpIHNldFVzZXJBY2NvdW50cyhhY2NvdW50cyB8fCBbXSk7XG4gICAgICAgICAgICAgIH0sIGN1cnJlbnRFbmRwb2ludCk7XG4gICAgICAgICAgICB9IGNhdGNoIChmZXRjaEVycjogYW55KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGZldGNoIHVzZXIgYWNjb3VudHMgdmlhICR7Y3VycmVudEVuZHBvaW50fSAobm9uLWZhdGFsKTpgLCBmZXRjaEVycik7XG4gICAgICAgICAgICAgIGlmIChtb3VudGVkUmVmLmN1cnJlbnQpIHNldFVzZXJBY2NvdW50cyhbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3VjY2VzcyFcbiAgICAgICAgICBzdWNjZXNzZnVsSW5pdGlhbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICAgIGlmIChtb3VudGVkUmVmLmN1cnJlbnQpIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYERyaWZ0IGNsaWVudCBmdWxseSBpbml0aWFsaXplZCBhbmQgc3Vic2NyaWJlZCB2aWEgJHtjdXJyZW50RW5kcG9pbnR9YCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICBpZiAoIW1vdW50ZWRSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uL3N1YnNjcmlwdGlvbjogJHtlcnIubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCwgZXJyKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBMb2cgYWRkaXRpb25hbCBkaWFnbm9zdGljIGluZm8gYWJvdXQgdGhlIGZhaWx1cmVcbiAgICAgICAgICBpZiAoc2RrRGVidWdNb2RlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiRXJyb3IgZGV0YWlsczpcIiwge1xuICAgICAgICAgICAgICBlbmRwb2ludDogY3VycmVudEVuZHBvaW50LFxuICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgbmFtZTogZXJyLm5hbWUsXG4gICAgICAgICAgICAgIHN0YWNrOiBlcnIuc3RhY2ssXG4gICAgICAgICAgICAgIGlzUmF0ZUxpbWl0RXJyb3I6IGVyciBpbnN0YW5jZW9mIFJhdGVMaW1pdEVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgaXNOdWxsUmVmZXJlbmNlRXJyb3IgPSBlcnIubWVzc2FnZT8uaW5jbHVkZXMoJ0Nhbm5vdCByZWFkIHByb3BlcnRpZXMgb2YgbnVsbCcpO1xuXG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFJhdGVMaW1pdEVycm9yIHx8IGlzTnVsbFJlZmVyZW5jZUVycm9yKSB7XG4gICAgICAgICAgICAvLyBUcmVhdCBudWxsIHJlZmVyZW5jZSBlcnJvcnMgZHVyaW5nIGluaXQvc3ViIGxpa2UgcmF0ZSBsaW1pdHMgLSB0cnkgbmV4dCBlbmRwb2ludCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgY29uc3QgZXJyb3JUeXBlID0gZXJyIGluc3RhbmNlb2YgUmF0ZUxpbWl0RXJyb3IgPyBcIlJhdGUgbGltaXRcIiA6IFwiTnVsbCByZWZlcmVuY2VcIjtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtlcnJvclR5cGV9IGVycm9yIGhpdCBvbiAke2N1cnJlbnRFbmRwb2ludH0sIHRyeWluZyBuZXh0IGVuZHBvaW50Li4uYCk7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcChFTkRQT0lOVF9TV0lUQ0hfREVMQVkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZS9zdWJzY3JpYmUgdmlhICR7Y3VycmVudEVuZHBvaW50fSBhZnRlciByZXRyaWVzOmAsIGVycik7XG4gICAgICAgICAgICBhd2FpdCBzbGVlcChFTkRQT0lOVF9TV0lUQ0hfREVMQVkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRlbXB0SW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgLy8gQWZ0ZXIgbG9vcDogY2hlY2sgaWYgaW5pdGlhbGl6YXRpb24gZmFpbGVkIGFmdGVyIHRyeWluZyBhbGwgZW5kcG9pbnRzXG4gICAgICBpZiAoIXN1Y2Nlc3NmdWxJbml0aWFsaXphdGlvbiAmJiBtb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIERyaWZ0IGNsaWVudCBhZnRlciB0cnlpbmcgYWxsIFJQQyBlbmRwb2ludHMuXCIpO1xuICAgICAgICBzZXRFcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIERyaWZ0IGFmdGVyIHRyeWluZyBhbGwgYXZhaWxhYmxlIFJQQyBlbmRwb2ludHMuXCIpO1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB0b2FzdC5lcnJvcihcIkNvdWxkIG5vdCBjb25uZWN0IHRvIERyaWZ0LiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyIG9yIGNoZWNrIG5ldHdvcmsuXCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0aWFsaXplRHJpZnRDbGllbnQoKTtcblxuICAgIC8vIENsZWFudXAgZnVuY3Rpb25cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBjb25zb2xlLmxvZyhcIkRyaWZ0Q2xpZW50UHJvdmlkZXIgY2xlYW5pbmcgdXAuLi5cIik7XG4gICAgICBjb25zdCBjdXJyZW50RHJpZnRDbGllbnQgPSBkcmlmdENsaWVudDsgLy8gQ2FwdHVyZSBjdXJyZW50IHZhbHVlIGZvciBjbGVhbnVwXG4gICAgICBpZiAoY3VycmVudERyaWZ0Q2xpZW50ICYmIGlzU3Vic2NyaWJlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnREcmlmdENsaWVudC51bnN1YnNjcmliZSgpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHVuc3Vic2NyaWJpbmcgZnJvbSBEcmlmdCBjbGllbnQ6XCIsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaXNTdWJzY3JpYmVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGlzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIC8vIFJFTU9WRSBkcmlmdENsaWVudCBmcm9tIGRlcGVuZGVuY3kgYXJyYXlcbiAgfSwgW3B1YmxpY0tleSwgc2lnblRyYW5zYWN0aW9uLCBzaWduQWxsVHJhbnNhY3Rpb25zLCBvbkNvbm5lY3RlZCwgc2RrRGVidWdNb2RlXSk7IFxuXG4gIHJldHVybiAoXG4gICAgPERyaWZ0Q2xpZW50Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyBcbiAgICAgIGRyaWZ0Q2xpZW50LCBcbiAgICAgIHVzZXJBY2NvdW50cywgXG4gICAgICBlcnJvciwgXG4gICAgICBpc0xvYWRpbmcsXG4gICAgICBpc0Nvbm5lY3RlZCxcbiAgICAgIGlzU3Vic2NyaWJlZCxcbiAgICAgIGN1cnJlbnRScGNFbmRwb2ludFxuICAgIH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvRHJpZnRDbGllbnRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgY29uc3QgdXNlRHJpZnRDbGllbnQgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KERyaWZ0Q2xpZW50Q29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VEcmlmdENsaWVudCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgRHJpZnRDbGllbnRQcm92aWRlclwiKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07ICJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwiRHJpZnRDbGllbnQiLCJ1c2VXYWxsZXQiLCJDb25uZWN0aW9uIiwidG9hc3QiLCJSYXRlTGltaXRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsIkRyaWZ0Q2xpZW50Q29udGV4dCIsImRyaWZ0Q2xpZW50IiwidXNlckFjY291bnRzIiwiZXJyb3IiLCJpc0xvYWRpbmciLCJpc0Nvbm5lY3RlZCIsImlzU3Vic2NyaWJlZCIsImN1cnJlbnRScGNFbmRwb2ludCIsIlJQQ19FTkRQT0lOVFMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfSEVMSVVTX1JQQ19VUkwiLCJmaWx0ZXIiLCJCb29sZWFuIiwiTUFYX1JFVFJJRVNfUEVSX0VORFBPSU5UIiwiSU5JVElBTF9SRVRSWV9ERUxBWSIsIk1BWF9SRVRSWV9ERUxBWSIsIkVORFBPSU5UX1NXSVRDSF9ERUxBWSIsInNsZWVwIiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJnZXRKaXR0ZXIiLCJiYXNlRGVsYXkiLCJqaXR0ZXIiLCJNYXRoIiwicmFuZG9tIiwicmV0cnlXaXRoQmFja29mZiIsImZuIiwiZW5kcG9pbnQiLCJyZXRyaWVzIiwiZGVsYXkiLCJpc1JhdGVMaW1pdEVycm9yIiwiaW5jbHVkZXMiLCJzdGF0dXMiLCJ0b0xvd2VyQ2FzZSIsImNvbnNvbGUiLCJ3YXJuIiwibmV4dERlbGF5IiwibWluIiwiaml0dGVyZWREZWxheSIsImxvZyIsImNyZWF0ZUNvbm5lY3Rpb24iLCJycGNFbmRwb2ludCIsImNvbm5lY3Rpb24iLCJnZXRFcG9jaEluZm8iLCJzYWZlbHlFeGVjdXRlU2RrTWV0aG9kIiwibWV0aG9kTmFtZSIsIm1ldGhvZCIsImZhbGxiYWNrVmFsdWUiLCJkZWJ1ZyIsInJlc3VsdCIsInN0YWNrIiwidW5kZWZpbmVkIiwiRHJpZnRDbGllbnRQcm92aWRlciIsImNoaWxkcmVuIiwib25Db25uZWN0ZWQiLCJzZXREcmlmdENsaWVudCIsInNldFVzZXJBY2NvdW50cyIsInNldEVycm9yIiwic2V0SXNDb25uZWN0ZWQiLCJzZXRJc1N1YnNjcmliZWQiLCJzZXRJc0xvYWRpbmciLCJjdXJyZW50UnBjSW5kZXgiLCJzZXRDdXJyZW50UnBjSW5kZXgiLCJzZXRDdXJyZW50UnBjRW5kcG9pbnQiLCJwdWJsaWNLZXkiLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduQWxsVHJhbnNhY3Rpb25zIiwiaXNTdWJzY3JpYmVkUmVmIiwiaXNJbml0aWFsaXplZFJlZiIsIm1vdW50ZWRSZWYiLCJzZGtEZWJ1Z01vZGUiLCJjdXJyZW50IiwiaW5pdGlhbGl6ZURyaWZ0Q2xpZW50Iiwic3VjY2Vzc2Z1bEluaXRpYWxpemF0aW9uIiwiYXR0ZW1wdEluZGV4IiwibWF4RW5kcG9pbnRBdHRlbXB0cyIsImxlbmd0aCIsImN1cnJlbnRFbmRwb2ludCIsImNsaWVudENvbmZpZyIsIndhbGxldCIsIm9wdHMiLCJjb21taXRtZW50Iiwic2tpcFByZWZsaWdodCIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXkiLCJ2YWx1ZSIsInRvU3RyaW5nIiwiY2xpZW50Iiwic3Vic2NyaWJlIiwiZ2V0VXNlckFjY291bnRzRm9yQXV0aG9yaXR5Iiwic3Vic2NyaWJlUmVzdWx0Iiwic3Vic2NyaWJlRXJyb3IiLCJhY2NvdW50cyIsImZldGNoRXJyIiwiZXJyIiwiaXNOdWxsUmVmZXJlbmNlRXJyb3IiLCJlcnJvclR5cGUiLCJjdXJyZW50RHJpZnRDbGllbnQiLCJ1bnN1YnNjcmliZSIsImNhdGNoIiwiUHJvdmlkZXIiLCJ1c2VEcmlmdENsaWVudCIsImNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/DriftClientProvider.tsx\n"));

/***/ })

});